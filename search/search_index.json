{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Tutorial de TwinCAT 3","text":""},{"location":"#bienvenida","title":"Bienvenida","text":"<p>Bienvenido/a al tutorial de TwinCAT 3. Aqu\u00ed encontrar\u00e1s gu\u00edas y material de apoyo para trabajar con TwinCAT 3 a partir de ejemplos concretos de programas de automatizaci\u00f3n.</p>"},{"location":"#contenidos","title":"Contenidos","text":"<ul> <li>Beckhoff y TwinCAT 3</li> <li>Conceptos Generales</li> <li>Ejemplo - Demo</li> <li>Ejemplo - Carro B\u00e1sico</li> </ul> <p>Sugerencia</p> <p>Usa el men\u00fa lateral y el buscador para moverte r\u00e1pido.</p>"},{"location":"contenidos/00_presentacion/","title":"Beckhoff","text":""},{"location":"contenidos/00_presentacion/#la-empresa","title":"La Empresa","text":"<p>Beckhoff Automation GmbH &amp; Co. es un fabricante de tecnolog\u00eda de automatizaci\u00f3n con sede en Verl, en Renania del Norte-Westfalia (Alemania), y forma parte del Grupo Beckhoff. Fundada por Hans Beckhoff en 1980, la empresa implementa sistemas de automatizaci\u00f3n para la industria y la automatizaci\u00f3n de edificios.</p> <p>Su caracter\u00edstica esencial se materializ\u00f3 con el lanzamiento en 1986 del primer controlador industrial basado en PC del mercado. Esta fue una idea radical en aquel entonces: utilizar la potencia y flexibilidad de un ordenador est\u00e1ndar, en lugar de los sistemas de control propietarios y cerrados que dominaban la industria. Este concepto, que llamaron \"PC-based Control\" (control basado en PC), se convertir\u00eda en la piedra angular de la empresa y en una revoluci\u00f3n silenciosa para la automatizaci\u00f3n.</p> <p>Adem\u00e1s del uso de la tecnolog\u00eda de control basada en PC, desarrollada sobre la base de est\u00e1ndares abiertos, Beckhoff protagoniz\u00f3 en 2003 otro hito que revolucion\u00f3 las comunicaciones industriales: el desarrollo de EtherCAT (Ethernet for Control Automation Technology). Se trata de un bus de campo industrial en tiempo real basado en Ethernet, extremadamente r\u00e1pido y preciso, que desde entonces se ha convertido en un est\u00e1ndar mundial para la automatizaci\u00f3n de alto rendimiento, gestionado por un consorcio internacional del que forman parte miles de empresas.</p> <p>Manteniendo su esp\u00edritu pionero, Beckhoff ha continuado ampliando los l\u00edmites de la tecnolog\u00eda con sistemas extraordinarios:</p> <ul> <li>XTS (2011): XTS (eXtended Transportation System), un sistema de transporte lineal con m\u00faltiples motores independientes (movers) que permiten un movimiento altamente din\u00e1mico y flexible en una sola pista.</li> <li>XPlanar (2018): Sistema de transporte planar que hace levitar y mover libremente productos sobre un mosaico de m\u00f3dulos, ofreciendo una flexibilidad sin precedentes.</li> <li>MX-System (2024-2025): Sistema que elimina la necesidad de armarios de control, integrando toda la electr\u00f3nica y la fuente de alimentaci\u00f3n en m\u00f3dulos robustos y resistentes, dise\u00f1ados para ser montados directamente en la m\u00e1quina.</li> </ul>"},{"location":"contenidos/00_presentacion/#interes-didactico","title":"Inter\u00e9s Did\u00e1ctico","text":"<p>Desde un punto de vista did\u00e1ctico, Beckhoff presenta un ecosistema especialmente atractivo para su uso en entornos educativos y de formaci\u00f3n. Esta idoneidad se sustenta en tres pilares fundamentales que, en conjunto, suponen una clara ventaja frente a otras filosof\u00edas de automatizaci\u00f3n:</p> <ol> <li>Compromiso con los est\u00e1ndares abiertos: A diferencia de los ecosistemas cerrados y propietarios que a\u00fan persisten en la industria, Beckhoff basa su tecnolog\u00eda en est\u00e1ndares internacionales. Esto no solo garantiza la interoperabilidad con otros sistemas, sino que permite al alumnado adquirir conocimientos y competencias universales, transferibles a m\u00faltiples entornos tecnol\u00f3gicos, en lugar de limitarse a aprender a manejar un \u00fanico fabricante.</li> <li>Acceso sin barreras para el aprendizaje (Pol\u00edtica de licencias): Su modelo de negocio permite a estudiantes, investigadores y desarrolladores trabajar con el entorno TwinCAT de forma completamente gratuita durante la fase de desarrollo y aprendizaje. El entorno de programaci\u00f3n puede descargarse y ejecutarse sin ning\u00fan coste, eliminando la barrera econ\u00f3mica que imponen otros fabricantes con licencias muy costosas, incluso para fines acad\u00e9micos.</li> <li>Entorno de simulaci\u00f3n integrado: La posibilidad de ejecutar, depurar y validar c\u00f3digo de control de manera virtual es clave en la docencia. Beckhoff permite probar proyectos completos de automatismo utilizando \u00fanicamente un PC, sin necesidad de disponer de hardware f\u00edsico. Su potente emulador (Runtime) y simulador (UmRT_Default) integrados replican fielmente el comportamiento de los sistemas reales, facilitando la experimentaci\u00f3n, el autoaprendizaje y la comprensi\u00f3n de conceptos complejos de una manera pr\u00e1ctica, segura y accesible desde cualquier lugar.</li> </ol>"},{"location":"contenidos/00_presentacion/#twincat-2","title":"TwinCAT 2","text":"<p>En 1996, Beckhoff present\u00f3 su plataforma software, TwinCAT (The Windows Control and Automation Technology). TwinCAT es un completo paquete para la automatizaci\u00f3n que incluye un software de desarrollo de aplicaciones para PLC y control num\u00e9rico (CNC) y un Runtime, que convert\u00eda cualquier PC industrial en un potente controlador l\u00f3gico programable (PLC) y controlador de movimientos en tiempo real. De esta forma, integraba la l\u00f3gica de control con el mundo de la inform\u00e1tica, permitiendo ejecutar c\u00f3digo TwinCAT en tiempo real en cualquier ordenador con Windows y sentando las bases para el concepto de \u00abControl Basado en PC\u00bb.</p>"},{"location":"contenidos/00_presentacion/#componentes-principales","title":"Componentes Principales","text":"<p>La arquitectura de TwinCAT 2 se articula en torno a tres aplicaciones clave que trabajan de forma conjunta:</p> <ul> <li>PLC Control: Es el Entorno Integrado de Desarrollo (IDE) para la creaci\u00f3n de programas de control. Soporta la totalidad de los lenguajes definidos en el est\u00e1ndar internacional IEC 61131-3 (Texto Estructurado, Diagrama de Contactos, Diagrama de Funciones, etc.), ofreciendo un entorno completo para la programaci\u00f3n, depuraci\u00f3n y compilaci\u00f3n del c\u00f3digo de la aplicaci\u00f3n.</li> <li>System Manager: Es la herramienta de configuraci\u00f3n del sistema TwinCAT que permite la conexi\u00f3n (asociaci\u00f3n o vinculaci\u00f3n) de las variables de entradas y salidas de las tareas software con las se\u00f1ales f\u00edsicas presentes en los buses de campo.</li> <li>Runtime: Es una aplicaci\u00f3n inform\u00e1tica que emula el comportamiento de un aut\u00f3mata programable industrial (SoftPLC) en un ordenador con Windows. El Runtime se encarga de ejecutar el ciclo b\u00e1sico de funcionamiento del programa de usuario, gestionar las comunicaciones en tiempo real y actualizar el estado de las entradas y salidas. Por esta raz\u00f3n, cualquier PC embebido de Beckhoff se suministra habitualmente con un Runtime preinstalado, convirti\u00e9ndolo de facto en un PLC industrial listo para ejecutar c\u00f3digo IEC 61131-3.</li> </ul>"},{"location":"contenidos/00_presentacion/#versiones","title":"Versiones","text":"<p>TwinCAT 2 es un software propietario que actualmente se distribuye en dos paquetes principales:</p> <ul> <li>Versi\u00f3n R3: Este paquete est\u00e1 destinado a sistemas con Windows de 32 bits. Incluye tanto el entorno de desarrollo completo como el Runtime. El entorno de desarrollo puede usarse de forma gratuita, indefinida y con toda su funcionalidad. El Runtime, por su parte, dispone de una licencia gratuita limitada a 30 d\u00edas, que puede renovarse de forma indefinida con la simple reinstalaci\u00f3n del paquete.</li> <li>Versi\u00f3n x64 Engineering: Dise\u00f1ada para sistemas operativos Windows de 64 bits, contiene \u00fanicamente el entorno de desarrollo de TwinCAT 2, que al igual que en la versi\u00f3n R3, puede usarse de forma gratuita, indefinida y con toda su funcionalidad.</li> </ul>"},{"location":"contenidos/00_presentacion/#twincat-3","title":"TwinCAT 3","text":"<p>TwinCAT 3 es la evoluci\u00f3n del sistema de programaci\u00f3n de Beckhoff, puesto a disposici\u00f3n del gran p\u00fablico a partir de 2012. Al igual que su predecesor, es un completo paquete para la automatizaci\u00f3n que incluye un software de desarrollo de aplicaciones para PLC y control num\u00e9rico y un Runtime que permite ejecutar en tiempo real c\u00f3digo TwinCAT en cualquier ordenador con Windows.</p> <p>TwinCAT 3 representa la evoluci\u00f3n del concepto de SoftPLC hacia la eXtended Automation (XA). A diferencia de TwinCAT 2, no es una aplicaci\u00f3n independiente, sino que se integra como una extensi\u00f3n dentro de Microsoft Visual Studio, convirti\u00e9ndolo en un entorno de desarrollo (IDE) de primer orden.</p> <p>En TwinCAT 3, las funciones que antes estaban separadas en diferentes aplicaciones (System Manager y PLC Control) se fusionan en una \u00fanica herramienta integrada:</p> <ul> <li>Engineering (XAE): Es el entorno de configuraci\u00f3n y programaci\u00f3n. Puede integrarse en Visual Studio o en su versi\u00f3n aislada TcXaeShell, disfrutando de todas las prestaciones que ofrece un IDE profesional (depuraci\u00f3n, control de versiones, etc.). TcXaeShell es una versi\u00f3n personalizada por Beckhoff del Shell de Visual Studio 2017.</li> <li>Runtime (XAR): Es el motor de ejecuci\u00f3n en tiempo real. Se ejecuta en modo kernel, lo que le permite tomar el control de uno o varios n\u00facleos del procesador (Multi-core) para garantizar que las tareas de automatizaci\u00f3n se ejecuten con determinismo, independientemente de la carga de trabajo de Windows.</li> </ul> <p>Los componentes principales del IDE son:</p> <ul> <li>Configuraci\u00f3n de Sistema (System): Donde se gestiona el hardware, la asignaci\u00f3n de n\u00facleos del procesador y las tareas (tasks).</li> <li>Configuraci\u00f3n de I/O: Sustituye al antiguo System Manager. Aqu\u00ed se escanean los buses de campo (siendo EtherCAT el est\u00e1ndar nativo) y se vinculan (mapean) las variables del PLC con las se\u00f1ales f\u00edsicas.</li> <li>PLC: Entorno de programaci\u00f3n basado en la norma IEC 61131-3. En TwinCAT 3, se introducen de lleno la Programaci\u00f3n Orientada a Objetos (POO) y el uso de Texto Estructurado (ST) como lenguaje principal.</li> </ul> <p>A diferencia de TwinCAT 2, cuyo Runtime s\u00f3lo funciona en sistemas de 32 bits, TwinCAT 3 est\u00e1 dise\u00f1ado para arquitecturas modernas de 64 bits. Adem\u00e1s del tradicional emulador (Runtime), dispone de un simulador (UmRT_Default) capaz de procesar c\u00f3digo IEC, aunque sin las prestaciones de tiempo real del emulador.</p>"},{"location":"contenidos/00_presentacion/#modelo-de-licencias","title":"Modelo de Licencias","text":"<p>Uno de los grandes \u00e9xitos de TwinCAT 3 es su modelo de licencias, especialmente atractivo para el \u00e1mbito acad\u00e9mico y de ingenier\u00eda:</p> <ul> <li>Instalaci\u00f3n Gratuita: El entorno de desarrollo (XAE) es completamente gratuito y se puede instalar en cualquier PC para programar y configurar proyectos de forma indefinida.</li> <li>Licencias de Prueba (Trial de 7 d\u00edas): TC3 permite generar licencias temporales de 7 d\u00edas para todas sus funciones (PLC, HMI, Motion, Safety, Vision). Estas licencias se pueden renovar de forma infinita simplemente introduciendo un c\u00f3digo \"Captcha\".</li> <li>Licencias Hardware: Para entornos de producci\u00f3n, las licencias se adquieren de forma permanente y se vinculan al hardware (el PC embebido o un dongle USB).</li> </ul>"},{"location":"contenidos/01_conceptos/","title":"\u2714 Conceptos generales","text":"Leyenda Abrev. Significado CD Clic derecho del rat\u00f3n CI Clic izquierdo del rat\u00f3n DCI Doble clic izquierdo del rat\u00f3n TC3 TwinCAT3 CV Campus Virtual FB Bloque funcional (Functional Block)"},{"location":"contenidos/01_conceptos/#interfaz-de-twincat-3","title":"Interfaz de TwinCAT 3","text":"<p>La imagen muestra el entorno de desarrollo TwinCAT 3 (TcXaeShell) integrado en Visual Studio. A continuaci\u00f3n se describen las principales zonas de la interfaz:</p> <p></p>"},{"location":"contenidos/01_conceptos/#resumen-estructural","title":"Resumen estructural","text":"<p>La interfaz de TC3 se divide conceptualmente en:</p> Zona Funci\u00f3n Barra superior Control del proyecto y del runtime Solution Explorer Organizaci\u00f3n estructural del proyecto Editor central Declaraci\u00f3n de variables (superior) y c\u00f3digo (inferior) Panel de propiedades Configuraci\u00f3n detallada Ventana inferior Diagn\u00f3stico y mensajes"},{"location":"contenidos/01_conceptos/#1-menus-y-barra-de-herramientas","title":"1. Men\u00fas y barra de herramientas","text":"<p>En la zona superior encontramos:</p>"},{"location":"contenidos/01_conceptos/#barra-de-menus","title":"Barra de men\u00fas","text":"<p>Incluye los men\u00fas cl\u00e1sicos:</p> <ul> <li>File</li> <li>Edit</li> <li>View</li> <li>Project</li> <li>Build</li> <li>Debug</li> <li>TwinCAT</li> <li>etc.</li> </ul> <p>Desde aqu\u00ed se gestionan acciones globales como compilar, activar configuraci\u00f3n, depurar o configurar el runtime.</p>"},{"location":"contenidos/01_conceptos/#barra-de-herramientas","title":"Barra de herramientas","text":"<p>Debajo del men\u00fa aparecen accesos r\u00e1pidos a:</p> <ul> <li>Selecci\u00f3n de configuraci\u00f3n (Debug / Release)</li> <li>Selecci\u00f3n del controlador (por ejemplo ) <li>Botones de Activar configuraci\u00f3n, Run Mode, Config Mode, Login, Start, Stop</li> <li>Selecci\u00f3n del proyecto activo</li> <li>Acceso r\u00e1pido a escritura y forzado de variables, reset del controlador, etc.</li>"},{"location":"contenidos/01_conceptos/#2-solution-explorer","title":"2. Solution Explorer","text":"<p>Es el \u00e1rbol estructural del proyecto.</p> <p>Aqu\u00ed se organizan:</p> <ul> <li>Solution<ul> <li>Proyecto PLC</li> <li>POUs (Program Organization Units)</li> <li>DUTs (Tipos de datos)</li> <li>GVLs (Variables globales)</li> <li>Visualizaciones</li> <li>Referencias</li> <li>I/O</li> <li>Tasks</li> </ul> </li> </ul> <p>Permite:</p> <ul> <li>Crear nuevos bloques (FB, PRG, etc.)</li> <li>A\u00f1adir tipos de datos</li> <li>Configurar hardware</li> <li>Gestionar instancias</li> </ul> <p>Es el centro de navegaci\u00f3n del proyecto.</p>"},{"location":"contenidos/01_conceptos/#3-editor-central","title":"3. Editor central","text":"<p>Zona central del trabajo. Es el \u00e1rea donde se edita el c\u00f3digo y los diagramas.</p> <p>Puede mostrar distintos tipos de editores:</p> <ul> <li>Structured Text (ST)</li> <li>Ladder (LD)</li> <li>FBD</li> <li>SFC</li> <li>Visualizaciones</li> </ul> <p>En la imagen se observan dos zonas diferenciadas dentro del mismo bloque:</p>"},{"location":"contenidos/01_conceptos/#declaracion-de-variables-parte-superior","title":"Declaraci\u00f3n de variables (parte superior)","text":"<p>Aqu\u00ed se definen:</p> <ul> <li><code>VAR_INPUT</code></li> <li><code>VAR_OUTPUT</code></li> <li><code>VAR</code></li> <li>Enumeraciones</li> <li>Instancias de bloques</li> <li>Variables mapeadas a entradas/salidas f\u00edsicas</li> </ul> <p>Es la zona donde se define la interfaz y memoria del bloque.</p>"},{"location":"contenidos/01_conceptos/#zona-de-codigo-parte-inferior","title":"Zona de c\u00f3digo (parte inferior)","text":"<p>Aqu\u00ed se implementa el c\u00f3digo del bloque. En el ejemplo se visualiza un diagrama SFC con:</p> <ul> <li>Pasos (<code>S0</code>, <code>S1</code>, <code>S2</code>...)</li> <li>Transiciones</li> <li>Acciones asociadas</li> <li>Condiciones l\u00f3gicas</li> </ul> <p>Pero se puede programar en cualquier lenguaje de la norma IEC-61131-3.</p>"},{"location":"contenidos/01_conceptos/#4-ventana-de-propiedades","title":"4. Ventana de Propiedades","text":"<p>Muestra las propiedades del elemento seleccionado:</p> <ul> <li>Nombre</li> <li>Comentario</li> <li>Paso inicial</li> <li>Acciones asociadas</li> <li>Tiempos m\u00ednimos o m\u00e1ximos</li> <li>Configuraci\u00f3n espec\u00edfica del objeto</li> </ul> <p>Es contextual: cambia seg\u00fan lo que est\u00e9 seleccionado (paso SFC, variable, bloque, etc.).</p>"},{"location":"contenidos/01_conceptos/#5-zona-inferior-output-error-list","title":"5. Zona inferior (Output / Error List)","text":"<p>En la parte inferior aparecen pesta\u00f1as como:</p> <ul> <li>Error List</li> <li>Output</li> <li>Estado de compilaci\u00f3n</li> </ul> <p>Sirve para:</p> <ul> <li>Ver errores de compilaci\u00f3n</li> <li>Advertencias</li> <li>Mensajes del sistema</li> <li>Informaci\u00f3n de activaci\u00f3n</li> </ul>"},{"location":"contenidos/01_conceptos/#crear-soluciones-en-tc3","title":"\ud83c\udfd7\ufe0f Crear soluciones en TC3","text":""},{"location":"contenidos/01_conceptos/#crear-proyecto-tc3","title":"Crear proyecto TC3","text":"<ol> <li>Abrir el software <code>Twincat XAE Shell</code>, desde el men\u00fa Inicio de Windows o desde el icono de la barra de programas en segundo plano que hay abajo a la derecha en la barra de tareas.</li> <li> <p>Seleccionar New TwinCAT Project.</p> <p></p> </li> <li> <p>Seleccionar el tipo TwinCAT XAE Project (XML format).</p> <p></p> </li> <li> <p>Darle un nombre a la Soluci\u00f3n, y seleccionar su ubicaci\u00f3n (la que viene por defecto est\u00e1 bien). Dejar marcada la opci\u00f3n Create directory for solution.</p> <p></p> <p>Ejemplo</p> <p><code>TC3_Lampara</code> </p> </li> <li> <p>Por defecto, tanto la Soluci\u00f3n de Visual Studio como el proyecto de TC3 tendr\u00e1n el mismo nombre.</p> </li> </ol> <p>Recomendaci\u00f3n</p> <p>Ocultar las secciones del proyecto que no se van a utilizar: <code>MOTION</code>, <code>SAFETY</code>, <code>C++</code>, <code>VISION</code>, <code>ANALYTICS</code>. Nos quedaremos solo con <code>SYSTEM</code>, <code>PLC</code> e <code>I/O</code>.</p>"},{"location":"contenidos/01_conceptos/#crear-proyecto-plc","title":"Crear proyecto PLC","text":"<ol> <li>Una vez creado un proyecto de TC3, procedemos a crear un proyecto PLC.</li> <li>Hacer CD sobre la secci\u00f3n <code>PLC</code> y seleccionar Add New Item.</li> <li> <p>Seleccionar Standard PLC Project, darle un nombre y pulsar Add. </p> <p>Ejemplo</p> <p><code>Lampara_PLC</code></p> </li> <li> <p>En la secci\u00f3n de <code>SYSTEM &gt; Tasks</code> aparecer\u00e1 por defecto una nueva tarea <code>PLC Task</code> con sus par\u00e1metros por defecto (ej. 10 ms de ciclo).</p> </li> <li> <p>En la secci\u00f3n <code>PLC</code> aparece el proyecto con dos secciones nuevas:</p> <ol> <li> <p><code>Project</code></p> <ol> <li><code>External Types</code>. Almacena definiciones de tipos de datos externos que provienen de fuentes externas al PLC.</li> <li><code>References</code>. Listado de referencias a las librer\u00edas utilizadas en el proyecto.</li> <li><code>DUTs</code>. Tipos de Dato de Usuario (Data User Types) (<code>ENUM</code>, <code>STRUCT</code>).</li> <li><code>GVLs</code>. Listas de Variables Globales (Global Variables Lists).</li> <li><code>POUs</code>. Unidades de Organizaci\u00f3n del Programa (Program Organization Units). Programas, bloques funcionales y funciones que implementaremos.</li> <li><code>VISUs</code>. Visualizaciones creadas.</li> <li> <p>Tarea creada (<code>PLCTask</code>) y programa <code>MAIN</code></p> <p></p> </li> </ol> </li> <li> <p><code>Instance</code>. Aqu\u00ed aparecer\u00e1n las variables en las im\u00e1genes de Entrada y Salida.</p> </li> </ol> </li> <li> <p>A partir de aqu\u00ed se puede empezar a implementar el proyecto.</p> </li> </ol>"},{"location":"contenidos/01_conceptos/#crear-bloque-funcional","title":"Crear bloque funcional","text":"<ol> <li>Hacer CD sobre la secci\u00f3n <code>POUs</code>.</li> <li>Seleccionar <code>Add \u2192 POU \u2192 Functional Block</code>.</li> <li>Darle un nombre significativo.</li> <li>Seleccionar el lenguaje a utilizar. Normalmente utilizaremos <code>ST</code> o <code>SFC</code>.</li> </ol>"},{"location":"contenidos/01_conceptos/#declaracion-de-variables","title":"\ud83c\udff7\ufe0f Declaraci\u00f3n de variables","text":"<p>Recomendaci\u00f3n</p> <p>Se recomienda utilizar la convenci\u00f3n CamelCase para declarar las variables.</p> <p>Como convenci\u00f3n adicional, a\u00f1adiremos un prefijo <code>i_</code> para aquellas variables que se declaren en la zona de entrada y <code>o_</code> para las de la zona de salida.</p> <ul> <li>Independientemente del lenguaje utilizado para implementar el c\u00f3digo, las variables se declaran de la misma manera.</li> <li>Las variables se declaran en la caja superior de la ventana del bloque funcional creado.</li> <li>La sintaxis para la declaraci\u00f3n de variables es la siguiente:</li> </ul> <pre><code>&lt;NombreVariable&gt; : &lt;tipo&gt; [:=&lt;ValorInicial&gt;]\n</code></pre> <p>Los tipos de datos m\u00e1s utilizados son los siguientes:</p> Tipo de dato Descripci\u00f3n <code>BOOL</code> Variable booleana/binaria. Solo puede valer <code>TRUE</code> o <code>FALSE</code>. <code>INT</code> Entero con signo de 16 bits (-32768 a 32767). <code>UINT</code> Entero sin signo de 16 bits (0 a 65535). <code>FLOAT</code> N\u00famero real en coma flotante (32 bits). Permite decimales. <code>TIME</code> Tipo de dato para representar tiempos o duraciones. <code>R_TRIG</code> Bloque de funci\u00f3n para detectar flanco ascendente (<code>FALSE</code> \u2192 <code>TRUE</code>). <code>TON</code> Temporizador a la conexi\u00f3n (retardo a la activaci\u00f3n). Activa la salida tras un tiempo. <code>ARRAY[x..y] OF ...</code> Conjunto de variables del mismo tipo indexadas entre <code>x</code> e <code>y</code>. <p>Ejemplo</p> <pre><code>// bool\nPulsador: BOOL;\nLuzAmarilla: BOOL := TRUE;\n\n// enteros con y sin signo\nAltura: INT;\nContador: UINT;\nUnidadesSolicitadas: UINT := 10;\n\n// n\u00fameros reales\nTpoSegundos: FLOAT := 1.2;\n\n// tiempo\nTiempoEspera: TIME := T#2s;\nTiempoRestante: TIME;\n\n// bloques funcionales\nFlanco_Pulsador: R_TRIG; // detector de flanco (est\u00e1ndar)\nTemporizador: TON; // temporizador (est\u00e1ndar)\nCoordinador: FB_Coordinador; // bloque funcional definido por el usuario\n\n// arrays\nOcupado: ARRAY[0..3] OF BOOL; // array de cuatro elementos de tipo BOOL; acceso con []\n</code></pre> <ul> <li> <p>La sintaxis de los valores posibles es la siguiente:</p> <ul> <li>Variables booleanas: <code>TRUE</code>, <code>FALSE</code>.</li> <li>Variables enteras: <code>0</code>, <code>1</code>, etc.</li> <li>Variables reales: <code>0.1</code>, <code>2.3</code>, etc.</li> <li> <p>Variables de tiempo: <code>T#&lt;tiempo&gt;</code> donde <code>&lt;tiempo&gt;</code> debe ser del estilo <code>&lt;numero&gt;&lt;unidad&gt;</code>, siendo <code>&lt;unidad&gt;</code> escogido de <code>{s, ms}</code>.</p> <p>Ejemplo</p> <p><code>T#2s</code> (dos segundos)</p> <p><code>T#500ms</code> (quinientos milisegundos).</p> </li> <li> <p>El acceso a los arrays se hace con el \u00edndice entre corchetes. </p> <p>Ejemplo</p> <p><code>Ocupado[1] := TRUE;</code></p> </li> </ul> </li> <li> <p>Ejemplos de llamadas a los bloques funcionales est\u00e1ndar:</p> <p>Ejemplo</p> <p>Detector de flanco: Se activa su salida <code>Flanco_Pulsador.Q</code> cuando la se\u00f1al <code>boton</code> pasa de <code>FALSE</code> a <code>TRUE</code>.     <pre><code>    Flanco_Pulsador(CLK := boton);\n</code></pre></p> <p>Ejemplo</p> <p>Temporizador: Se activa cuando la se\u00f1al <code>start</code> pasa a <code>TRUE</code> y activa su salida <code>Temporizador.Q</code> tras pasar 10s. <pre><code>    Temporizador(IN:=start, PT:=T#10s);\n</code></pre></p> </li> </ul> <p>Las variables en TC3 se declaran dentro de los \u00e1mbitos existentes en el POU correspondiente: locales, entrada y salida.</p>"},{"location":"contenidos/01_conceptos/#variables-locales","title":"Variables locales","text":"<pre><code>FUNCTIONAL_BLOCK FB_Estacion\nVAR\n    Contador: UINT;\nEND_VAR\n</code></pre> <p>Las variables declaradas aqu\u00ed se pueden utilizar dentro del POU pero no pueden tomar valores de fuera del POU ni se pueden acceder desde fuera del POU.</p>"},{"location":"contenidos/01_conceptos/#variables-de-entrada","title":"Variables de entrada","text":"<pre><code>FUNCTIONAL_BLOCK FB_Estacion\nVAR_INPUT\n    TiempoEntrada: TIME;\n    TiempoSalida: TIME := T#2s;\nEND_VAR\n</code></pre> <p>Las variables declaradas aqu\u00ed deben ser especificadas al llamar al FB (a no ser que se les de un valor por defecto).</p> <p>Importante</p> <p>No especificarlas en la llamada produce un error de compilaci\u00f3n.</p>"},{"location":"contenidos/01_conceptos/#variables-de-salida","title":"Variables de salida","text":"<pre><code>FUNCTIONAL_BLOCK FB_Estacion\nVAR_OUTPUT\n    LuzAmarilla: BOOL;\n    LuzVerde: BOOL;\nEND_VAR\n</code></pre> <p>Las variables declaradas aqu\u00ed pueden ser accedidas desde fuera del FB (por ejemplo, desde otro FB que llama a este, o desde el programa <code>MAIN</code>).</p> <pre><code>PROGRAM MAIN\nVAR\n    Estacion: FB_Estacion\n    LuzAmarillaEstacion: BOOL;\nEND_VAR\n------------------\nLuzAmarillaEstacion := Estacion.LuzAmarilla; // esto es v\u00e1lido\n</code></pre> <p>Importante</p> <p>Querer acceder a una variable de un FB que no ha sido declarada como salida produce un error de compilaci\u00f3n.</p>"},{"location":"contenidos/01_conceptos/#variables-de-entrada-y-salida","title":"Variables de entrada y salida","text":"<pre><code>FUNCTIONAL_BLOCK FB_Estacion\nVAR_IN_OUT\n    Contador: UINT;\nEND_VAR\n</code></pre> <p>Este \u00e1mbito no aparece por defecto al crear un FB pero puede ser a\u00f1adido simplemente escribiendo la secci\u00f3n <code>VAR_IN_OUT ... END_VAR</code>.</p> <p>Las variables declaradas aqu\u00ed deben tomar un valor como entrada al FB y su valor final tras cada ciclo puede ser accedido desde fuera del FB.</p> <p>Combina las condiciones de los \u00e1mbitos de entrada y salida.</p> <ul> <li>En un programa (ej. <code>MAIN</code>) s\u00f3lo disponemos del \u00e1mbito <code>VAR</code>.</li> <li>En un FB, adem\u00e1s del \u00e1mbito <code>VAR</code>, disponemos de los \u00e1mbitos <code>VAR_INPUT</code> y <code>VAR_OUTPUT</code>.</li> </ul>"},{"location":"contenidos/01_conceptos/#variables-vinculadas-a-la-es","title":"Variables vinculadas a la E/S","text":"<p>Recuerda que la memoria del PLC est\u00e1 estructurada en tres secciones: la imagen de entrada, la imagen de salida y la zona de marcas.</p>"},{"location":"contenidos/01_conceptos/#zona-de-marcas","title":"Zona de marcas","text":"<p>Aqu\u00ed se guardar\u00e1n aquellas variables que son internas al programa y no van a ser vinculadas con terminales de entrada y salida.</p> <p>Las variables declaradas con la siguiente sintaxis se guardan en la zona de marcas:</p> <pre><code>VAR\n    Pulsador: BOOL;\n    Contador: UINT;\n    Lampara: BOOL;\nEND_VAR\n</code></pre>"},{"location":"contenidos/01_conceptos/#imagen-de-entrada","title":"Imagen de entrada","text":"<p>Aqu\u00ed se guardar\u00e1n las variables que queremos vincular a las entradas f\u00edsicas del sistema.</p> <p>Su sintaxis a\u00f1ade <code>AT %I*</code> antes de la definici\u00f3n del tipo:</p> <pre><code>VAR\n    i_Pulsador AT %I*: BOOL;\nEND_VAR\n</code></pre> <p>Importante</p> <p>En nuestro trabajo usaremos la convenci\u00f3n de a\u00f1adir un prefijo <code>i_</code> delante de estas variables.</p>"},{"location":"contenidos/01_conceptos/#imagen-de-salida","title":"Imagen de salida","text":"<p>Aqu\u00ed se guardar\u00e1n las variables que queremos vincular a las salidas f\u00edsicas del sistema.</p> <p>Su sintaxis a\u00f1ade <code>AT %Q*</code> antes de la definici\u00f3n del tipo:</p> <pre><code>VAR\n    o_Lampara AT %Q*: BOOL;\nEND_VAR\n</code></pre> <p>Importante</p> <p>En nuestro trabajo usaremos la convenci\u00f3n de a\u00f1adir un prefijo <code>o_</code> delante de estas variables.</p> <p>Importante</p> <p>Declarar una variable en la imagen de entrada o salida es independiente de que sean entradas o salidas del bloque funcional.</p> <p>Estas declaraciones son completamente correctas.</p> <pre><code>VAR_INPUT\n    Pulsador AT %I*: BOOL;\n    LamparaAmarilla AT %Q*: BOOL;\n    TiempoEspera: TIME;\nEND_VAR\n\nVAR\n    LamparaMarcha AT %Q*: BOOL;\nEND_VAR\n\nVAR_OUTPUT\n    PresenciaPale AT %I*: BOOL;\nEND_VAR\n</code></pre>"},{"location":"contenidos/01_conceptos/#crear-visualizacion","title":"\ud83d\udda5\ufe0f Crear visualizaci\u00f3n","text":"<ul> <li> <p>Hacer CD sobre la secci\u00f3n <code>VISUs</code>.</p> </li> <li> <p>Seleccionar <code>Add \u2192 Visualization</code> y pulsar en Open en la ventana popup.</p> <p></p> </li> <li> <p>En la parte derecha de la pantalla aparecer\u00e1 la secci\u00f3n <code>Toolbox</code> donde, en la secci\u00f3n <code>Basic</code> aparecen las formas b\u00e1sicas. Arrastrar a la visualizaci\u00f3n los elementos que se quieran.</p> </li> </ul> <p>Importante</p> <p>Si no aparece la secci\u00f3n, mostrarlo entrando en el Men\u00fa <code>View \u2192 Toolbox</code></p> <p>Recomendaci\u00f3n</p> <p>Se recomienda utilizar rect\u00e1ngulos para crear botones tanto para las entradas como para las salidas.</p>"},{"location":"contenidos/01_conceptos/#botones-para-cambiar-valores-de-variables","title":"Botones para cambiar valores de variables","text":"<ul> <li> <p>Dibujar un rect\u00e1ngulo con el tama\u00f1o deseado.</p> </li> <li> <p>Escribir dentro la etiqueta que queramos que aparezca en el bot\u00f3n.</p> </li> <li> <p>Introducir la variable de tipo <code>BOOL</code> que queremos asociar a dicho bot\u00f3n. Dependiendo del comportamiento que queramos que tenga el bot\u00f3n, esta variable se introduce en una secci\u00f3n distinta dentro de <code>Properties \u2192 Input Configuration</code> (la pesta\u00f1a <code>Properties</code> aparece a la derecha, normalmente combinada con <code>Toolbox</code>).</p> <ul> <li> <p>Si queremos que la variable cambie de valor mientras se pulsa el bot\u00f3n con el rat\u00f3n pero vuelva a su valor anterior una vez soltado el rat\u00f3n, introduciremos la variable en la secci\u00f3n <code>Tap</code>:</p> <p></p> </li> <li> <p>Si queremos que la variable cambie de valor cada vez que pulsemos el bot\u00f3n lo introduciremos en la secci\u00f3n <code>Toggle</code> (el valor conmutar\u00e1 entre <code>TRUE</code> y <code>FALSE</code>):</p> <p></p> </li> </ul> </li> </ul>"},{"location":"contenidos/01_conceptos/#ejecutar-programa","title":"\u25b6\ufe0f Ejecutar programa","text":"<p>Una vez el programa est\u00e1 implementado (independientemente del lenguaje utilizado):</p> <ul> <li>Compilar el proyecto: Men\u00fa <code>Build \u2192 Build [nombre del proyecto]</code>.</li> <li>Asegurarse de que no hay errores.</li> <li>Si has declarado variables en las im\u00e1genes de entrada y/o salida:     <ul> <li>Comprobar que las variables aparecen en la zona de la instancia.     </li> </ul> </li> </ul>"},{"location":"contenidos/01_conceptos/#seleccionar-el-controlador","title":"Seleccionar el controlador","text":"<p>El programa puede ser ejecutado en distintos \"controladores\"</p> <ul> <li>Emulador <code>Local</code>.</li> <li>Simulador <code>Um_RT</code> (User Mode Real Time). Recomendado para el laboratorio.</li> <li>Controlador remoto (PLC).</li> </ul>"},{"location":"contenidos/01_conceptos/#emulador-local","title":"Emulador local","text":"<p>Para poder usar este controlador debemos haberle dejado a TwinCAT 3 que tuviera acceso al kernel de Windows durante la instalaci\u00f3n, de manera que pueda hacer uso de, al menos, un core del equipo para ejecutar el programa. </p> <p>El emulador local ejecuta el programa exactamente de la misma manera que si lo hici\u00e9ramos en un equipo remoto pero, obviamente, no tenemos acceso al hardware. De esta forma, podremos interactuar con las variables de entrada y salida mediante la escritura/forzado de variables o usando la visualizaci\u00f3n (si hemos dise\u00f1ado alguna para controlar las variables).</p> <p>En este caso no tendremos que asociar las variables a los terminales de E/S ya que no habr\u00e1 ninguno disponible.</p> <p>Para usar este controlador, simplemente aseg\u00farate de seleccionar <code>Local</code> en el desplegable del <code>Target</code>.</p> <p></p> <p>Importante</p> <p>La instalaci\u00f3n y uso de este modo tiene ciertos requisitos que se cumplen en la mayor\u00eda de los equipos en los que se puede instalar, pero, en ocasiones, puede dar alg\u00fan problema de incompatibilidad. Para estos casos, se recomienda utilizar el simulador local explicado m\u00e1s adelante.</p>"},{"location":"contenidos/01_conceptos/#simulador-local","title":"Simulador local","text":"<p>TwinCAT 3 proporciona una v\u00eda alternativa al emulador local que permite ejecutar c\u00f3digo en un simulador en \"modo usuario\" dentro de Windows. La diferencia principal con el emulador es que \u00e9ste garantiza el tiempo de ciclo del sistema mientras que el simulador no lo hace. A\u00fan as\u00ed, las restricciones de tiempo de los programas que usaremos no son muy exigentes as\u00ed que el simulador ser\u00e1 suficiente para una ejecuci\u00f3n satisfactoria. A cambio, elimina los problemas de compatibilidad que la instalaci\u00f3n del emulador local pueda tener.</p> <p>Al igual que con el emulador local, no tendremos que asociar las variables a los terminales de E/S, ya que no habr\u00e1 ninguno disponible. De nuevo, podremos interactuar con las variables de entrada y salida mediante la escritura/forzado de variables o usando la visualizaci\u00f3n (si hemos dise\u00f1ado alguna para controlar las variables).</p> <p>Para usar este controlador, tendremos que ejecutar en \"modo Administrador\" el archivo <code>TC3_UmRT_Start.bat</code> que proporcionamos en la carpeta <code>Automatizaci\u00f3n &gt; programas</code> del CV. Esto abrir\u00e1 un terminal de Windows con la informaci\u00f3n relativa a la ejecuci\u00f3n del simulador. Minimizaremos esta ventana y la dejaremos trabajar de fondo.</p> <p>Error</p> <p>Se ha detectado que este procedimiento no funciona en los PCs del laboratorio por lo que, alternativamente, hay que realizar lo siguiente:</p> <p>Pulsar <code>Win+R</code> e introducir el siguiente texto:  <code>C:\\TwinCAT\\3.1\\Runtimes\\UmRT_Default\\Start.bat</code></p> <p>Importante</p> <p>No debemos cerrar la ventana del terminal de Windows abierto por <code>TC3_UmRT_Start.bat</code> mientras queramos usar este simulador.</p> <p>Una vez hecho esto, aparecer\u00e1 el texto <code>UmRT_Default</code> en el desplegable del target: </p> <p>Importante</p> <p>Una vez finalizado nuestro trabajo con el simulador, pulsaremos la tecla <code>'x'</code> en el terminal para apagar el simulador y se cerrar\u00e1 autom\u00e1ticamente la ventana.</p>"},{"location":"contenidos/01_conceptos/#controlador-remoto-plc","title":"Controlador remoto (PLC)","text":"<p>Por \u00faltimo, podremos ejecutar nuestro programa en un controlador remoto (por ejemplo, el PLC de alguna de las estaciones). De esta manera, tendremos acceso al hardware que est\u00e9 conectado al controlador y podremos interactuar con \u00e9l.</p> <p>Importante</p> <p>En este punto, asumiremos que ya hemos encontrado el controlador en la red del laboratorio (como se explica aqu\u00ed y ya hemos escaneado los terminales de E/S que est\u00e1n conectados al controlador (como se explica aqu\u00ed).</p> <p>Para usar este controlador, lo seleccionaremos en el desplegable de <code>Target</code>.  </p> <p>Al usar este controlador, tendremos acceso al hardware conectado a \u00e9l, y podremos vincular las variables que hemos declarado en las im\u00e1genes de entrada y salida con los terminales y canales que queramos. Para ello, simplemente repetiremos este proceso para cada variable:</p> <ul> <li> <p>DCI sobre la variable a vincular en la lista que aparece en la secci\u00f3n de instancia del proyecto.</p> <p></p> </li> <li> <p>Seleccionar el terminal/canal deseado del listado que aparece.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/#activar-la-configuracion","title":"Activar la configuraci\u00f3n","text":"<p>Una vez realizada la selecci\u00f3n del controlador y la asociaci\u00f3n de variables con los terminales de E/S (si procede), ahora debemos env\u00edar esta informaci\u00f3n al controlador en cuesti\u00f3n. Esto se denomina Activar la configuraci\u00f3n.</p> <p>Para ello, deberemos pulsar el icono de Activate Configuration y activar el modo de ejecuci\u00f3n (Run Mode) cuando nos lo pregunte TwinCAT3 en una ventana popup.</p> <p></p>"},{"location":"contenidos/01_conceptos/#transferir-y-ejecutar-el-programa","title":"Transferir y ejecutar el programa","text":"<p>Posteriormente, debemos enviar el programa al controlador pulsando el icono de Login, tras lo que se preguntar\u00e1, en un popup, si queremos crear un puerto de comunicaci\u00f3n con el controlador y descargar el programa. Pulsaremos en Yes.</p> <p></p> <p>Finalmente, pondremos el programa en ejecuci\u00f3n pulsando el icono Start.</p> <p></p> <p>Importante</p> <p>Para poder modificar de nuevo el programa, primero hay que parar el programa (Stop) (recomendado) y posteriormente hacer Logout.</p> <p></p>"},{"location":"contenidos/01_conceptos/#busqueda-de-controladores-remotos","title":"\ud83c\udf10 B\u00fasqueda de controladores remotos","text":"<p>Recomendaci\u00f3n</p> <p>Hay un video de ejemplo en el Campus Virtual en <code>Automatizaci\u00f3n &gt; Videos &gt; TC3</code> con nombre <code>9_Runtime_Target_*.mkv</code>.</p> <p>En esta secci\u00f3n explicaremos c\u00f3mo buscar controladores remotos en la red del laboratorio y c\u00f3mo escanear los terminales/canales que tienen conectados.</p>"},{"location":"contenidos/01_conceptos/#busqueda-en-red","title":"B\u00fasqueda en red","text":"<p>Si queremos utilizar un controlador remoto (PLC), lo primero que debemos hacer es buscarlo en la red local del laboratorio y establecer una conexi\u00f3n con \u00e9l. Para ello, seguiremos este procedimiento:</p> <ul> <li> <p>Desplegar <code>Target</code> y seleccionar <code>Choose Target System...</code>.</p> <p></p> <p></p> <ul> <li> <p>Pulsar sobre <code>Search (Ethernet)</code></p> <p>Importante</p> <p>Aceptar si aparece el siguiente mensaje: Searching for remote system only possible from local system. Change back to local system.</p> <ul> <li> <p>Se abre el siguiente cuadro de di\u00e1logo:</p> <p></p> </li> <li> <p>Seleccionar <code>\ud83d\udd33 Advanced Settings</code>.</p> </li> <li> <p>Pulsar sobre el bot\u00f3n <code>Broadcast Search</code>.</p> <ul> <li> <p>Seleccionar los adaptadores de red en el popup.</p> <p></p> </li> </ul> </li> <li> <p>Seleccionar el PLC de la lista que aparezca.</p> </li> <li>Marcar <code>\ud83d\udd33 IP Address</code></li> <li>Pulsar en el bot\u00f3n <code>Add Route</code>.</li> <li>En el popup que aparece (Add Remote Route):<ul> <li>Deseleccionar <code>\ud83d\udd32 Secure ADS</code></li> <li>Escribir: <code>User</code> el que corresponda (Administrator, por defecto).</li> <li>Escribir: <code>Password</code> la que corresponda (1, por defecto).</li> </ul> </li> <li>Observar que aparece una <code>x</code> en la columna Connected.</li> <li>Cerrar el cuadro de di\u00e1logo pulsando <code>Close</code>.</li> </ul> </li> <li> <p>Ahora deber\u00eda aparecer el controlador en el listado del cuadro de di\u00e1logo <code>Choose Target System</code>:</p> <ul> <li>Seleccionar el controlador en la lista y pulsar <code>OK</code>.</li> </ul> </li> <li>Si aparece un popup indicando que es necesario cambiar la plataforma, pulsar en <code>Yes</code>.</li> </ul> </li> </ul>"},{"location":"contenidos/01_conceptos/#escaneado-del-controlador","title":"Escaneado del controlador","text":"<p>Importante</p> <p>Para poder hacer este proceso, debemos asegurarnos que TwinCAT 3 est\u00e1 en modo configuraci\u00f3n (Configuration Mode) y no en ejecuci\u00f3n (Run Mode).</p> <p></p> <p>Comenzamos por buscar los dispositivos de entrada/salida conectados al controlador. Para ello:</p> <ul> <li> <p>En el explorador de la soluci\u00f3n (<code>Solution Explorer</code>):</p> <ul> <li>Seleccionar: <code>I/O &gt; Device</code>.</li> <li>Pulsar en el men\u00fa <code>TwinCAT &gt; Scan (BD Scan)</code> (alternativamente, CD sobre <code>I/O Device</code> y pulsar <code>Scan</code>).</li> <li>Aceptar el mensaje de que no todos los dispositvos pueden encontrarse autom\u00e1ticamente.</li> <li>Seleccionar \u00fanicamente el dispositivo EtherCAT y pulsar <code>OK</code>.</li> <li>Aceptar la b\u00fasqueda de boxes (terminales) pulsando <code>Yes</code>.</li> <li>Aceptar la activaci\u00f3n del modo Free Run pulsando <code>Yes</code>.</li> </ul> </li> <li> <p>Observar el arbol de I/O en el explorador de la soluci\u00f3n.</p> </li> <li> <p>Desplegar el elemento <code>EK1200</code> y verificar que la lista de terminales se corresponde con la configuraci\u00f3n del controlador (en su documentaci\u00f3n).</p> <p>Info</p> <p>Tened en cuenta que el terminal <code>EL9011</code> es un elemento virtual.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/#comprobacion-de-los-terminales","title":"Comprobaci\u00f3n de los terminales","text":"<p>Ahora vamos a comprobar alguno de los terminales de E/S para asegurarnos de que tenemos acceso a ellos. Usaremos un ejemplo en el que tendremos un programa con una variable de entrada <code>i_PulsadorMarcha</code> y una variable de salida <code>o_LamparaMarcha</code>.</p> <p>El procedimiento a seguir es el siguiente:</p> <ul> <li> <p>Buscar en el listado de E/S del controlador la entrada correspondiente al pulsador de marcha:</p> <ul> <li>Localizar el Terminal y el Canal de entrada especificado.</li> <li>Desplegar el contenido del Canal y hacer DC sobre su <code>Input</code>.</li> <li>Seleccionar la pesta\u00f1a Online y verificar que se corresponde con el pulsador:<ul> <li>Accionar el pulsador de marcha y observar el cambio de valor mostrado en la gr\u00e1fica.</li> </ul> </li> </ul> <p>Importante</p> <p>Se recomienda seleccionar la pesta\u00f1a Variable y cambiar el nombre de <code>Input</code> por el nombre de la variable asociada en el listado de E/S (por ejemplo, <code>i_PulsadorMarcha</code>). </p> <p>Este paso NO vincula el terminal/canal con la variable sino que simplemente lo renombra para ayudarnos a localizarlo posteriormente durante el proceso de vinculaci\u00f3n.</p> </li> <li> <p>Buscar en el listado de E/S del controlador la salida correspondiente a la l\u00e1mpara de marcha:    </p> <ul> <li>Localizar el Terminal y el Canal de salida especificado.</li> <li>Desplegar el contenido del Canal y hacer DC sobre su <code>Output</code>.</li> <li>Seleccionar la pesta\u00f1a Online y verificar que se corresponde con la l\u00e1mpara:<ul> <li>Pulsar <code>Write</code>.</li> <li>Pulsar alternativamente <code>0</code>/<code>1</code> y comprobar que la l\u00e1mpara se enciende y se apaga.</li> </ul> </li> </ul> <p>Importante</p> <p>Se recomienda seleccionar la pesta\u00f1a Variable y cambiar el nombre <code>Output</code> por el nombre de la variable asociada en el listado de E/S (por ejemplo, <code>o_LamparaMarcha</code>). </p> <p>Este paso NO vincula el terminal/canal con la variable sino que simplemente lo renombra para ayudarnos a localizarlo posteriormente durante el proceso de vinculaci\u00f3n.</p> </li> </ul> <p>Una vez realizado esto, guardamos el proyecto.</p>"},{"location":"contenidos/01_conceptos/#vinculacion-de-variables-y-es","title":"\ud83d\udd17 Vinculaci\u00f3n de variables y E/S","text":"<p>Recomendaci\u00f3n</p> <p>Hay un video de ejemplo en el Campus Virtual en <code>Automatizaci\u00f3n &gt; Videos &gt; TC3</code> con nombre <code>9_Runtime_Target_*.mkv</code>.</p> <p>Una vez se han revisados y renombrados los terminales/canales de E/S del controlador, procedemos a vincularlos con las variables de nuestro programa.</p> <p>El procedimiento es el siguiente (siguiendo con el ejemplo anterior de pulsador/l\u00e1mpara):</p> <ul> <li>DC sobre el canal nombrado como <code>o_LamparaMarcha</code> (<code>DB &gt; Change Link...</code>):<ul> <li>Seleccionar la variable que queremos vincular <code>MAIN.o_Lampara</code> en la instancia <code>PLCTask Input</code> y pulsar <code>OK</code>.<ul> <li>Observar c\u00f3mo cambian los iconos del canal <code>o_LamparaMarcha</code> y de la variable <code>MAIN.o_Lampara</code> en la instancia (aparece una flecha sobre el icono en ambos casos, indicando que hay una vinculaci\u00f3n).</li> </ul> </li> </ul> </li> <li> <p>DC sobre la variable <code>MAIN.i_Pulsador</code> en la instancia <code>PLCTask Input</code> (<code>DB &gt; Change Link...</code>)</p> <ul> <li>Seleccionar en I/O el canal correspondiente a i_Pulsador<ul> <li>De la misma manera, cambian los iconos del canal <code>o_LamparaMarcha</code> y de la variable <code>MAIN.o_Lampara</code> en la instancia.</li> </ul> </li> </ul> <p>Info</p> <p>Esta operaci\u00f3n se puede hacer desde la instancia hacia la entrada/salida o al rev\u00e9s.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/#activardesactivar-hardware","title":"\ud83d\udd0c Activar/desactivar hardware","text":"<ol> <li>Si has vinculado las variables de tu programa con el equipo remoto (hiciste la b\u00fasqueda del equipo remoto y la exploraci\u00f3n de los m\u00f3dulos de E/S), cuando quieras probar tu programa en el Runtime Local, aparecer\u00e1 una ventana popup indicando un error.</li> <li>Esto se debe a que TC3 quiere establecer conexi\u00f3n con el hardware al que estuviste conectado pero no puede, ya que el <code>Target</code> es el local.</li> <li>Para evitar esto, solo tienes que deshabilitar el hardware haciendo CD sobre el dispositivo buscado y seleccionar Disable.</li> </ol> <p>Importante</p> <p>Recuerda volver a habilitarlo cuando quieras volver a usar el equipo remoto.</p>"},{"location":"contenidos/01_conceptos/#creacion-de-duts","title":"\ud83d\udc6b Creaci\u00f3n de DUTs","text":"<p>Adem\u00e1s de los tipos de datos simples (<code>BOOL</code>, <code>INT</code>, etc.) y los bloques funcionales ya existentes (<code>R_TRIG</code>) o creados por nosotros (<code>FB_Coordinador_ST</code>), en ocasiones podemos necesitar crear tipos de dato que est\u00e1n compuestos por otros tipos de dato. A estos tipos de datos se les denomina tipos de unidad de datos (Data Unit Type, DUT).</p> <p>En nuestros proyectos vamos a poder hacer uso de dos de ellos: </p> <ul> <li>Estructuras (<code>STRUCT</code>)</li> <li>Enumeraciones (<code>ENUM</code>).</li> </ul>"},{"location":"contenidos/01_conceptos/#estructuras","title":"Estructuras","text":"<p>Aglutinan en su interior otros tipos de dato y se definen haciendo CD sobre la carpeta DUTs y escogiendo <code>Add \u2192 DUT</code>:</p> <p></p> <p>Se le da un nombre significativo (se recomienda comenzar con <code>ST</code> como, por ejemplo, <code>ST_PIEZA</code>), se deja marcado Structure y se pulsa en Open.</p> <p>Se abrir\u00e1 una ventana de texto para definir los componentes del tipo de dato:</p> <pre><code>TYPE ST_PIEZA :\nSTRUCT\n    Blanca: BOOL;\n    Baja: BOOL;\n    Tamano: INT;\n    Tiempo: TIME;\nEND_STRUCT\nEND_TYPE\n</code></pre> <p>Para usarlo, se define una variable de ese tipo y se accede a sus componentes mediante el operador <code>.</code> (punto):</p> <pre><code>// Definicion de variables\nVAR\n    Pieza: ST_PIEZA;\n    Baja: BOOL;\nEND_VAR\n--------------------------------\n// Implementacion\nPieza.Blanca := TRUE;\nBaja := (Pieza.Tamano &lt; 12);\nPieza.Tiempo := T#1s;\n</code></pre>"},{"location":"contenidos/01_conceptos/#enumeraciones","title":"Enumeraciones","text":"<p>Una enumeraci\u00f3n (<code>ENUM</code>) es un tipo de datos definido por el usuario compuesto por una serie de componentes separados por comas, tambi\u00e9n llamados valores de enumeraci\u00f3n, que se utiliza para declarar variables definidas por el usuario.</p> <p>Se definen haciendo CD sobre la carpeta DUTs y escogiendo <code>Add \u2192 DUT</code>:</p> <p></p> <p>Se le da un nombre significativo (se recomienda comenzar con <code>E</code> como, por ejemplo,  <code>E_ColorBasic</code>), se deja marcado Enumeration y se pulsa en Open.</p> <p>Se abrir\u00e1 una ventana de texto para definir los componentes del tipo de dato:</p> <pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_ColorBasic :\n(\n    eRed, \n    eYellow,\n    eGreen,\n    eBlue,\n    eBlack\n) // Basic data type is INT, default initialization is eRed\n;\nEND_TYPE\n</code></pre> <p>Una variable definida con el tipo <code>E_ColorBasic</code> es, en realidad, de tipo <code>INT</code> y solo puede tomar los valores definidos en <code>E_ColorBasic</code>: <code>eRed</code>, <code>eYellow</code>, etc.</p> <p>Cada uno de esos valores tiene un valor <code>INT</code> asociado, comenzando por el cero: <code>eRed = 0</code>, <code>eYellow = 1</code>, etc.</p> <p>Para usarlo, se define una variable de ese tipo y se le asigna el valor deseado usando el nombre del tipo de dato Enumeration:</p> <pre><code>// Definicion de variables\nVAR\n    Color: E_ColorBasic;\nEND_VAR\n--------------------------------\n// Implementacion\nColor := E_ColorBasic.eYellow; // asignacion de valor\nIF Color &lt;&gt; E_ColorBasic.eRed THEN // comprobacion de valor\n    [...]\nEND_IF\n</code></pre>"},{"location":"contenidos/01_conceptos/#declaracion-compacta","title":"Declaraci\u00f3n compacta","text":"<p>Importante</p> <p>Este m\u00e9todo se utiliza si el tipo va a ser utilizado solo en un mismo POU. Si se pretende utilizar el tipo enumerado declarado en m\u00e1s de uno, es m\u00e1s conveniente declararlo como DUT siguiendo el procedimiento anterior.</p> <p>Existe otra manera m\u00e1s compacta de declarar una variable de tipo Enumeration. Para ello, basta con declarar el nombre de la variable y los posibles valores que puede tomar. </p> <pre><code>VAR\n    Estado : (E_Reposo, E_MarchandoDerecha, E_MarchandoIzquierda);\nEND_VAR\n</code></pre>"},{"location":"contenidos/01_conceptos/#lenguaje-st","title":"\ud83d\udcc4 Lenguaje ST","text":"<p>Recomendaci\u00f3n</p> <p>Es recomendable acceder a la ayuda y documentaci\u00f3n del lenguaje ST (Structured Text) que ofrece Beckhoff en su portal Infosys.</p>"},{"location":"contenidos/01_conceptos/#sintaxis-general","title":"Sintaxis general","text":"<ul> <li>Las instrucciones deben terminar con <code>;</code>.</li> <li>Los comentarios se pueden realizar con <code>//</code> hasta final de l\u00ednea o metiendo el texto entre <code>(*</code> y <code>*)</code>.</li> <li>La asignaci\u00f3n de valores entre variables se realiza con el operador <code>:=</code>.</li> <li>La comparaci\u00f3n de valores se realiza con los operadores <code>=</code>, <code>&lt;&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.</li> <li>Las operaciones l\u00f3gicas se realizan con los operadores <code>AND</code>, <code>OR</code> y <code>NOT</code>.</li> <li>La llamada a los FBs se realiza escribiendo el nombre de la instancia del FB seguido de, entre par\u00e9ntesis, las asignaciones de los valores para las variables de entrada (si las hay), separadas por comas: <code>&lt;nombre_instancia&gt;(var1:=val1, var2:=val2, ...);</code></li> <li> <p>En caso de que no haya ninguna variable de entrada que especificar, simplemente se abre y se cierra par\u00e9ntesis.</p> <p>Ejemplo</p> <p><code>Estacion();</code></p> <p><code>Lampara(TiempoEncedido:=T#2s);</code></p> </li> </ul>"},{"location":"contenidos/01_conceptos/#estructuras-de-control","title":"Estructuras de control","text":"<ul> <li>Las estructuras de control b\u00e1sicas son:<ul> <li>Condicionales (<code>if</code>, <code>case</code>)     <pre><code>IF &lt;condition&gt; THEN\n    &lt;statements&gt;\nELSIF &lt;condition&gt; THEN\n    &lt;statements&gt;\nELSE\n    &lt;statements&gt;\nEND_IF;\n\nCASE &lt;expression&gt; OF\n    &lt;value&gt;, &lt;value&gt;, \u2026, &lt;value&gt;: &lt;statements&gt;\nELSE\n    &lt;statements&gt;\nEND_CASE;\n</code></pre></li> <li>Bucles (<code>for</code>, <code>while</code>, <code>repeat</code>)     <pre><code>FOR &lt;variable&gt; := &lt;expression&gt; TO &lt;expression&gt; BY &lt;expression&gt; DO\n    &lt;statements&gt;\nEND_FOR;\n\nWHILE &lt;condition&gt; DO\n    &lt;statements&gt;\nEND_WHILE;\n\nREPEAT\n    &lt;statement&gt;\nUNTIL &lt;condition&gt;\nEND_REPEAT;\n</code></pre></li> </ul> </li> </ul>"},{"location":"contenidos/01_conceptos/#lenguaje-sfc","title":"\u2935\ufe0f Lenguaje SFC","text":""},{"location":"contenidos/01_conceptos/#reglas-sintacticas","title":"Reglas sint\u00e1cticas","text":"<ul> <li>Los nombres de las etapas en SFC (Sequential Function Chart) no pueden empezar por un n\u00famero. Tampoco pueden tener espacios, puntos u otros caracteres especiales como e\u00f1es, interrogaciones, etc. S\u00ed permite guiones bajos.</li> <li>No puede haber dos etapas consecutivas ni dos transiciones consecutivas. Hay que tener especial atenci\u00f3n a esto cuando se produzcan bifurcaciones o saltos.</li> </ul>"},{"location":"contenidos/01_conceptos/#anadir-etapa-transicion","title":"A\u00f1adir etapa / transici\u00f3n","text":"<ul> <li>Hacer CD sobre la etapa donde queramos introducir una nueva y seleccionar Add step-transition o Add step-transition after, dependiendo de si queremos a\u00f1adirla antes o despu\u00e9s, respectivamente, de la etapa seleccionada.</li> </ul> <p>Importante</p> <p>Comprobar que no quedan dos etapas o dos transiciones consecutivas. En caso contrario, borrar aquello que no sirva (CI sobre \u00e9l y pulsar Supr).</p>"},{"location":"contenidos/01_conceptos/#asociar-acciones-a-etapas","title":"Asociar acciones a etapas","text":""},{"location":"contenidos/01_conceptos/#accion-continua","title":"Acci\u00f3n continua","text":"<p>Las acciones continuas se ejecutan de manera continuada mientras el sistema est\u00e1 en la etapa asociada. Esto nos va a permitir:</p> <ul> <li>Activar una se\u00f1al booleana durante todo el tiempo que la etapa est\u00e9 activa. </li> <li>Ejecutar una acci\u00f3n m\u00e1s compleja asociada al FB de manera continua mientras la etapa est\u00e9 activa.</li> </ul> <p>El procedimiento para su creaci\u00f3n es el siguiente:</p> <ul> <li>Hacer CD sobre la etapa a la que queramos asociar una acci\u00f3n no memorizada (o continua) y seleccionar Insert action association o Insert action association after, dependiendo de si queremos insertarla antes o despu\u00e9s de las ya existentes (si las hay).</li> <li>En la caja de la acci\u00f3n aparece en primer lugar el modificador (por defecto <code>N</code>, que significa \"No memorizada\") y en segundo lugar el hueco donde debemos poner la acci\u00f3n a realizar.</li> </ul>"},{"location":"contenidos/01_conceptos/#senal-booleana","title":"Se\u00f1al booleana","text":"<p>Si queremos activar una se\u00f1al booleana, bastar\u00e1 con escribir su nombre en la caja de acci\u00f3n.</p> <p></p> <p>Existen varios tipos de modificadores de acciones:</p> C\u00f3digo Tipo Descripci\u00f3n <code>N</code> No memorizada (continua) Se ejecuta/activa mientras la etapa est\u00e9 activa. <code>R0</code> Reinicio La acci\u00f3n se desactiva. <code>S0</code> Activaci\u00f3n Se ejecuta cuando se activa la etapa y contin\u00faa activa aunque la etapa se desactive. <code>L</code> Limitada Se ejecuta cuando se activa la etapa y se desactiva cuando la etapa se desactiva o se alcanza el tiempo especificado. <code>D</code> Retrasada Se ejecuta un tiempo despu\u00e9s de que se active la etapa y se desactiva cuando la etapa se desactiva. <code>P</code> Pulsada Se ejecuta dos veces: cuando se activa la etapa y una vez m\u00e1s en el ciclo siguiente. <code>SD</code> Activaci\u00f3n con retardo Se activa aunque la etapa ya no est\u00e9 activa. <code>DS</code> Retardo de activaci\u00f3n Se activa solo si la etapa permanece activa. <code>SL</code> Activaci\u00f3n limitada Activaci\u00f3n con duraci\u00f3n limitada. <p>Importante</p> <p>Usaremos, por defecto, las acciones no memorizadas, aunque se pueden usar las otras si tiene sentido para el proyecto.</p>"},{"location":"contenidos/01_conceptos/#accion-compleja","title":"Acci\u00f3n compleja","text":"<p>Si, por el contrario, lo que queremos asociar a esta etapa es una acci\u00f3n compleja, tendremos que realizar el siguiente procedimiento:</p> <ul> <li> <p>A\u00f1adir una acci\u00f3n haciendo CD sobre el FB donde queremos usar la acci\u00f3n y seleccionar <code>Add &gt; Action...</code></p> <p></p> </li> <li> <p>Especificar el nombre de la acci\u00f3n que queramos y seleccionar el lenguaje en el que la vamos a implementar.</p> <p></p> <p>Sugerencia</p> <p>En nuestro trabajo tomaremos la convenci\u00f3n de a\u00f1adir el prefijo <code>a_</code> a las acciones que creemos de este modo.</p> </li> <li> <p>Escribir el c\u00f3digo de la acci\u00f3n, como por ejemplo:</p> <pre><code>BLK();\no_LamparaMarcha := (S0.x AND BLK.Q) OR NOT S0.x;\n</code></pre> </li> <li> <p>Asociarlo a una etapa en la caja de acci\u00f3n cont\u00ednua.</p> <p></p> </li> <li> <p>A partir de este momento, el c\u00f3digo de la acci\u00f3n se ejecutar\u00e1 de manera continua (en cada ciclo b\u00e1sico del PLC) mientras la etapa asociada est\u00e9 activa.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/#accion-de-entrada-o-salida","title":"Acci\u00f3n de entrada o salida","text":"<p>Tambi\u00e9n podemos crear acciones con activaci\u00f3n a la entrada o a la salida de una etapa. Estas acciones se implementan en cualquiera de los lenguajes de la norma y permiten realizar acciones que se ejecutan solo una vez durante la etapa, en lugar de hacerse de manera continua.</p>"},{"location":"contenidos/01_conceptos/#a-la-entrada","title":"A la entrada","text":"<ul> <li>Las acciones con activaci\u00f3n a la entrada se ejecutan solo una vez inmediatamente despu\u00e9s de entrar en la etapa donde se asocian. Posteriormente se comprueba si la condici\u00f3n de transici\u00f3n para pasar a la siguiente etapa es cierta o no.</li> <li>Normalmente usaremos estas acciones para inicializar variables memorizadas, actualizar contadores, etc.</li> <li>Para crear una de este tipo, hacer CD sobre la etapa donde la queremos asociar y seleccionar Add entry action.</li> <li> <p>Aparece un popup donde se nos pregunta por el nombre que le queremos poner y el lenguaje a utilizar. Se recomienda dejar el nombre por defecto (<code>S0_entry</code> en la figura) ya que nos indica en qu\u00e9 etapa est\u00e1 y de qu\u00e9 tipo es.</p> <p></p> </li> <li> <p>En nuestros proyectos, estas acciones siempre ser\u00e1n implementadas en <code>ST</code>, pero podr\u00edan ser codificadas en cualquier otro lenguaje de la norma.</p> </li> <li> <p>Una vez creada, se representa en el programa <code>SFC</code> como un cuadrado con una E en la esquina inferior izquierda de la etapa.</p> <p></p> </li> </ul>"},{"location":"contenidos/01_conceptos/#a-la-salida","title":"A la salida","text":"<ul> <li>Las acciones con activaci\u00f3n a la salida se ejecutan solo una vez inmediatamente antes de pasar a la siguiente etapa. Esto implica que antes de que se ejecute esta acci\u00f3n, la condici\u00f3n de transici\u00f3n para pasar a la siguiente etapa debe ser cierta.</li> <li>Normalmente usaremos estas acciones para inicializar variables memorizadas, actualizar contadores, etc.</li> <li>Para crear una de este tipo, hacer CD sobre la etapa donde la queremos asociar y seleccionar Add exit action.</li> <li> <p>Aparece un popup donde se nos pregunta por el nombre que le queremos poner y el lenguaje a utilizar. Se recomienda dejar el nombre por defecto (<code>S0_exit</code> en la figura) ya que nos indica en qu\u00e9 etapa est\u00e1 y de qu\u00e9 tipo es.</p> <p></p> <p>Importante</p> <p>En nuestros proyectos, estas acciones siempre ser\u00e1n en <code>ST</code>, pero podr\u00edan ser implementadas en cualquier otro lenguaje de la norma.</p> </li> <li> <p>Una vez creada, se representa en el programa <code>SFC</code> como un cuadrado con una X en la esquina inferior derecha de la etapa.        </p> </li> </ul> <p>Importante</p> <p>Nada impide que una etapa tenga asociadas una o varias acciones no memorizadas, una con activaci\u00f3n a la entrada y otra con activaci\u00f3n a la salida.</p>"},{"location":"contenidos/01_conceptos/#accion-principal","title":"Acci\u00f3n principal","text":"<p>Existe un cuarto tipo de acciones que podemos utilizar: las acciones principales. Estas acciones tambi\u00e9n se asocian a una etapa y se ejecutan de manera continua durante todo el tiempo que la etapa est\u00e9 activa.</p> <p>El procedimiento de creaci\u00f3n de estas acciones es el mismo que el indicado aqu\u00ed pero, en lugar de introducir el nombre de la acci\u00f3n en la caja de acci\u00f3n, lo introduciremos en el campo <code>Main Action</code> dentro de las propiedades de la etapa.</p> <p></p> <p>Una vez asociada a la etapa, aparece representada en el diagrama SFC con un tri\u00e1ngulo oscuro en la esquina superior derecha de la misma.</p> <p></p> <p>Importante</p> <p>Conceptualmente no hay diferencia sustancial con las acciones complejas utilizadas en las cajas de acci\u00f3n, pero tomaremos la convenci\u00f3n de utilizar este tipo de acciones cuando las variables involucradas no est\u00e9n relacionadas con las E/S hardware de nuestro sistema y las acciones en la caja de acci\u00f3n en caso contrario.</p>"},{"location":"contenidos/01_conceptos/#estructuras-de-evolucion","title":"\ud83d\udd00 Estructuras de evoluci\u00f3n","text":""},{"location":"contenidos/01_conceptos/#secuencia-basica","title":"Secuencia b\u00e1sica","text":"<ul> <li> <p>Una secuencia b\u00e1sica se compone de una sucesi\u00f3n lineal de etapas y transiciones, donde las primeras se van a ir ejecutando en secuencia conforme las condiciones asociadas a las segundas se vayan cumpliendo.</p> </li> <li> <p>Normalmente, al final de la secuencia se producir\u00e1 un salto hacia atr\u00e1s (o el inicio) en el programa.</p> <p></p> </li> <li> <p>Para insertar un salto detr\u00e1s de una transici\u00f3n, hay que hacer CD sobre la transici\u00f3n y seleccionar Insert jump after. Solo hay que indicar el nombre de la etapa a la que queremos saltar.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/#bifurcacion","title":"Bifurcaci\u00f3n","text":"<ul> <li> <p>Tras una etapa podemos realizar una bifurcaci\u00f3n en distintas ramas en funci\u00f3n de distintas condiciones. Esto nos permite dirigir la secuencia por un camino si ocurre un evento y por otros distintos si ocurren otros eventos.</p> </li> <li> <p>En el ejemplo de la figura, si la etapa <code>Init</code> est\u00e1 activa y se activa <code>Execute</code>, el programa evolucionar\u00e1 por la rama de la izquierda llegando a <code>S0</code>. Si lo que se activa es <code>Restore</code>, el programa evolucionar\u00e1 por la derecha pasando a <code>Sr</code> y, una vez se active <code>Restaurado</code>, la secuencia pasar\u00e1 a <code>S0</code>.</p> <p></p> </li> <li> <p>Para realizar una bifurcaci\u00f3n, hacer CD sobre la transici\u00f3n donde se quiera hacer la bifurcaci\u00f3n (<code>Execute</code> en el ejemplo) y seleccionar Insert branch right.</p> </li> <li> <p>Nada impide que se pueda hacer una bifurcaci\u00f3n con m\u00e1s de dos ramas.</p> </li> <li> <p>Es recomendable que las condiciones de la bifurcaci\u00f3n sean excluyentes pero nada impide que no lo sean. El programa tomar\u00e1 el camino de la primera transici\u00f3n cuya condici\u00f3n sea verdadera de izquierda a derecha.</p> </li> <li> <p>Si ocurriera que varias o todas las condiciones son verdaderas a la vez, el programa evolucionar\u00e1 por la rama de la izquierda. Aunque esto puede ser \u00fatil en algunos casos, esto suele indicar que hay un mal dise\u00f1o en el programa.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/#paralelismo","title":"Paralelismo","text":"<ul> <li> <p>Si queremos que el programa evolucione por dos secuencias en paralelo (se ejecutan simult\u00e1neamente) podemos incluir un paralelismo en el c\u00f3digo.</p> </li> <li> <p>En el ejemplo de la figura, si la etapa <code>Init</code> est\u00e1 activa y se activa <code>Execute</code>, el programa evolucionar\u00e1 por ambas ramas a la vez, activando los estados <code>S0</code> y <code>Sr</code> de manera simult\u00e1nea (y por tanto, <code>LuzRoja</code> y <code>Restaura</code>).</p> <p></p> </li> <li> <p>En la transici\u00f3n con condici\u00f3n <code>NOT Pulsador OR S0.t&gt;T#5s</code> se produce un punto de sincronizaci\u00f3n ya que, para que el programa evolucione a <code>S1</code> debe ocurrir que <code>S0</code> y <code>Sr2</code> est\u00e9n activas y, adem\u00e1s, que la condici\u00f3n <code>NOT Pulsador OR S0.t&gt;T#5s</code> sea cierta. Por tanto, podemos decir que el programa esperar\u00e1 hasta que termine la rama de la derecha antes de evolucionar.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/#exportar-e-importar","title":"\ud83d\udd04 Exportar e importar","text":"<ol> <li>Podemos exportar <code>POUs</code> y <code>VISUs</code> desde una soluci\u00f3n de TC3 e importarla de nuevo en otra distinta. De esta manera podemos reutilizar c\u00f3digo de distintas proyectos.</li> <li>Para realizar esto, en la soluci\u00f3n origen, simplemente hay que hacer CD sobre el <code>POU</code> o <code>VISU</code> a exportar y seleccionar Export to ZIP. Se selecciona donde guardar el archivo exportado y se pulsa Save.</li> <li>Posteriormente, en la soluci\u00f3n destino, hacer CD sobre la carpeta <code>POU</code> o <code>VISU</code> y seleccionar Import from ZIP. Se busca el archivo correspondiente y se pulsa OK.</li> </ol>"},{"location":"contenidos/01_conceptos/#guardar-y-mover-proyectos","title":"\ud83d\udcbe Guardar y mover proyectos","text":"<p>Importante</p> <p>Se ha detectado que el sincronizar la carpeta del proyecto usando servicios como Google Drive est\u00e1 produciendo problemas a la hora de poder abrir los proyectos. Posiblemente esto se deba a que algunos ficheros no son sincronizados correctamente por Drive (por motivos desconocidos), lo que lleva a que, a la hora de abrir el proyecto, no se carguen los ficheros necesarios. </p> <p>Se recomienda, por tanto, no usar este m\u00e9todo sino alguno de los otros.</p>"},{"location":"contenidos/01_conceptos/#usando-la-carpeta-completa","title":"Usando la carpeta completa","text":"<ol> <li>Es la manera m\u00e1s sencilla de llevarse un proyecto desde un equipo a otro.</li> <li> <p>Solo hay que copiar la carpeta ra\u00edz en un pendrive y pegar la carpeta en el equipo destino.</p> <p></p> </li> <li> <p>Posteriormente, hacer DCI sobre el fichero de Solution (<code>.sln</code>) para que se abra de nuevo en TC3.</p> </li> </ol> <p>Importante</p> <p>Si la carpeta ha sido comprimida para ser trasladada, hay que asegurarse de haber descomprimido la carpeta completa en el destino antes de abrir el proyecto.</p>"},{"location":"contenidos/01_conceptos/#guardando-como-tnzip","title":"Guardando como <code>.tnzip</code>","text":"<p>Importante</p> <p>La entrega final del proyecto deber\u00e1 seguir este procedimiento.</p> <ol> <li>Este proceso genera el m\u00ednimo tama\u00f1o posible para trasladar un proyecto.</li> <li>Seleccionar <code>File \u2192 Save [nombre_del_proyecto] as Archive...</code>.</li> <li>Seleccionar d\u00f3nde guardar el proyecto, darle un nombre y asegurarse de que el formato es de tipo <code>.tnzip</code>.</li> </ol>"},{"location":"contenidos/01_conceptos/#abrir-un-fichero-tnzip","title":"Abrir un fichero <code>.tnzip</code>","text":"<p>Una vez movido el fichero <code>.tnzip</code> al equipo destino, para volver a abrir el proyecto, seguimos este procedimiento:</p> <ul> <li>Abrir TC3.</li> <li>Seleccionar <code>File \u2192 Open \u2192 Solution from Archive...</code>.</li> <li>Buscar el archivo <code>.tnzip</code>.</li> <li>Seleccionar (o crear si no existe) la carpeta donde queremos que se genere la Solution.</li> </ul> <p>Sugerencia</p> <p>En principio, se puede seleccionar siempre la misma carpeta cada vez que se repita este procedimiento.</p> <p>Importante</p> <p>Si al abrir el proyecto de nuevo y compilar obtienes errores no relacionados con el c\u00f3digo que antes no ten\u00edas:</p> <ul> <li>Cambiar el tipo de proyecto a TwinCAT RT (x86)</li> <li>Recompilar</li> <li>Volver a cambiar a TwinCAT RT (x64)</li> <li>Volver a recompilar</li> </ul>"},{"location":"contenidos/01_conceptos/#usando-git","title":"Usando GIT","text":"<p>TwinCAT3, al estar basado en Visual Studio, tiene compatibilidad directa con GitHub.  Se recomienda seguir el tutorial en este video:</p> <p>PLC Programming using TwinCAT 3 - Version control</p>"},{"location":"contenidos/01_conceptos/#convenciones-de-nombres","title":"\ud83d\udcdd Convenciones de nombres","text":"<p>Se recomienda llamar a todos los elementos del proyecto con el nombre adecuado desde el principio, ya que renombrar a posteriori puede acarrear problemas derivados del acceso a elementos cuya ruta ha cambiado. No obstante, si es necesario renombrar los elementos, el procedimiento es como sigue.</p>"},{"location":"contenidos/01_conceptos/#soluciones","title":"Soluciones","text":"<p>Se recomienda llamar a las soluciones de TC3 de la misma forma que los Proyectos de TC3.</p> <p>Para renombrarlo una vez creado:</p> <ol> <li> <p>CD sobre el nombre de la soluci\u00f3n y seleccionar Rename.</p> <p></p> </li> <li> <p>Escribir el nuevo nombre.</p> </li> </ol>"},{"location":"contenidos/01_conceptos/#proyectos-twincat3","title":"Proyectos TwinCAT3","text":"<ul> <li> <p>Se recomienda llamar a los proyectos TC3 de la siguiente forma:</p> <ul> <li> <p>Para los ejemplos: <code>TC3_[nombre]</code>   donde el nombre debe ser algo significativo.</p> <p>Ejemplo</p> <p><code>TC3_Lampara</code></p> <p><code>TC3_Carro</code></p> </li> <li> <p>Para los trabajos finales: <code>[codigo]_TC3_G[grupo]</code>   donde <code>codigo</code> debe escogerse seg\u00fan la asignatura (<code>AIM</code>, <code>AIE</code>, <code>SR</code>, etc.) y <code>grupo</code> debe ser el n\u00famero del grupo con dos d\u00edgitos (<code>01</code>, <code>02</code>, ...).</p> <p>Ejemplo</p> <p><code>AIM_TC3_G01</code></p> <p><code>SR_TC3_G12</code></p> </li> <li> <p>C\u00f3digos de las asignaturas:</p> C\u00f3digo Asignatura AIM Automatizaci\u00f3n Industrial de GIERM AIE Automatizaci\u00f3n Industrial de GIEI o GIEI+IEL SR Sistemas Robotizados de GITI </li> <li> <p>Para renombrarlo una vez creado:</p> <ul> <li> <p>CD sobre el nombre del proyecto TC3 y seleccionar Rename.</p> <p></p> </li> <li> <p>Escribir el nuevo nombre.</p> </li> </ul> </li> </ul> </li> </ul>"},{"location":"contenidos/01_conceptos/#proyectos-plc","title":"Proyectos PLC","text":"<ul> <li> <p>Se recomienda llamar a los proyectos PLC de la forma <code>[nombre]_PLC</code> para los ejemplos o <code>[estacion]_[nivel]_PLC</code> para los trabajos, donde el nombre debe ser algo significativo.</p> <p>Ejemplo</p> <p><code>Lampara_PLC</code></p> <p><code>FMS201_Monolitico_PLC</code></p> </li> <li> <p>Para renombrarlo una vez creado:</p> <ol> <li> <p>CD sobre el nombre del proyecto PLC y seleccionar Rename.</p> <p></p> </li> <li> <p>Escribir el nuevo nombre.</p> </li> <li> <p>Aparecer\u00e1 un aviso indicando que si se cambia el nombre del proyecto no se van a poder hacer cambios online (en caso de que se est\u00e9 ejecutando). CI en S\u00ed.</p> <p></p> </li> <li> <p>Tras unos segundos, el proyecto PLC habr\u00e1 cambiado de nombre.</p> </li> <li>Importante: Puede ocurrir que, tras el cambio de nombre, al hacer CI sobre el proyecto, salga un aviso de error por no encontrar el nombre anterior. Esto se debe solucionar haciendo CI sobre <code>Build \u2192 Rebuild Solution</code>.</li> </ol> </li> </ul>"},{"location":"contenidos/01_conceptos/#bloques-funcionales","title":"Bloques Funcionales","text":"<ul> <li>Se recomienda llamar a los bloques funcionales de la forma <code>FB_[nombre]_[lenguaje]</code>, donde el nombre debe ser algo significativo.</li> <li> <p>Los lenguajes suelen ser:</p> <ul> <li><code>ST</code> (Structured Text)</li> <li><code>SFC</code> (Sequential Function Chart)</li> </ul> <p>Ejemplo</p> <p><code>FB_Estacion_ST</code></p> <p><code>FB_Coordinador_ST</code></p> <p><code>FB_Alimentador_SFC</code></p> </li> <li> <p>Para renombrarlo una vez creado:</p> <ol> <li>CD sobre el nombre del FB y seleccionar Rename.</li> <li>Escribir el nuevo nombre.</li> <li> <p>Aparecer\u00e1 un aviso indicando que se van a adaptar todas las referencias en el proyecto. Pulsar en Yes.</p> <p></p> </li> <li> <p>Aparecer\u00e1 una ventana mostrando todos los cambios que se van a realizar. Pulsar en OK.</p> <p></p> </li> </ol> </li> </ul>"},{"location":"contenidos/01_conceptos/#variables","title":"Variables","text":"<ul> <li>Se recomienda llamar a las variables con nombres significativos.</li> <li>Si las variables se van a asociar con los terminales de entrada y salida, es obligatorio llamarlas con el nombre indicado en la columna Variable de la tabla de E/S.</li> <li>Para renombrar una variable y que ese cambio se corrija en todas las referencias que se hagan a la misma en el proyecto, hay que hacer CD sobre el nombre de la variable y seleccionar <code>Refactoring \u2192 Rename</code>.</li> <li> <p>Aparecer\u00e1 un popup donde se debe indicar el nuevo nombre.</p> <p></p> </li> <li> <p>Aparecer\u00e1 una ventana mostrando todos los cambios que se van a realizar. Pulsar en OK.</p> <p></p> </li> </ul>"},{"location":"contenidos/02_tc3_demo/","title":"\ud83d\udc4b Demo (TwinCAT 3)","text":""},{"location":"contenidos/02_tc3_demo/#descripcion-del-proyecto","title":"\ud83d\udcdd Descripci\u00f3n del Proyecto","text":"<p>El proyecto Demo pretende ser un Hola Mundo para automatas programables (PLC). </p> <p>Es un proyecto m\u00ednimo y funcional, que muestra la declaraci\u00f3n y el uso b\u00e1sico de variables booleanas y enteras, ubicadas en los espacios de memoria de marcas, imagen de entrada e imagen de salida. Cubriendo los elementos esenciales de programaci\u00f3n de los lenguajes de la norma IEC 61131-3 para la programaci\u00f3n de PLC.</p> <p></p> <p>Este proyecto incluye adem\u00e1s, una visualizaci\u00f3n elemental que permite interactuar con las variables del proyecto, con objetos gr\u00e1ficos. Formas rectangulares para mostrar el valor de variables booleanas y num\u00e9ricas y botones para modificar el valor de variables booleanas y num\u00e9ricas.</p>"},{"location":"contenidos/02_tc3_demo/#codigo","title":"C\u00f3digo","text":"<p>Declaraci\u00f3n</p> <pre><code>PROGRAM MAIN\nVAR\n    ContadorCiclos    : UINT; // Variable num\u00e9rica en el espacio de marcas\n    i_Pulsador AT %I* : BOOL; // Variable booleana en la imagen de entrada\n    o_Lampara  AT %Q* : BOOL; // Variable booleana en la imagen de salida\nEND_VAR\n</code></pre> <p>C\u00f3digo</p> <pre><code>// Uso de una variable num\u00e9rica (se incrementa con cada ciclo de ejecuci\u00f3n)\nContadorCiclos := ContadorCiclos + 1;\n\n// Uso de variables de entrada y salida booleanas (copia la entrada en la salida)\no_Lampara := i_Pulsador;\n</code></pre>"},{"location":"contenidos/02_tc3_demo/#comentarios","title":"Comentarios","text":"<ul> <li>La variable <code>ContadorCiclos</code> se incrementa indefinidamente una vez por ciclo b\u00e1sico de ejecuci\u00f3n del PLC (10 ms).</li> <li>La variable de salida <code>o_Lampara</code> copia, continuamente, el valor de la variable de entrada <code>i_Pulsador</code>.</li> <li>El valor de la variable <code>ContadorCiclos</code> se muestra en la visualizaci\u00f3n.</li> <li>La variable <code>ContadorCiclos</code> puede reinicarse si se acciona el pulsador <code>Reinicia</code>.</li> <li>El valor de la variable <code>o_Lampara</code> se muestra con el cambio de color del rect\u00e1ngulo <code>Lampara</code> (verde claro = <code>false</code>, verde oscuro = <code>true</code>).</li> <li>El valor de la variabale <code>i_Pulsador</code> cambia cuando se acciona el bot\u00f3n <code>Pulsador</code>.</li> </ul>"},{"location":"contenidos/02_tc3_demo/#requisitos-del-sistema","title":"\ud83d\udcbb Requisitos del Sistema","text":""},{"location":"contenidos/02_tc3_demo/#software","title":"Software","text":"<ul> <li>IDE: Microsoft Visual Studio / TwinCAT 3 XAE (Versi\u00f3n m\u00ednima recomendada: 3.1.4024.x).</li> <li>Lenguajes: Texto Estructurado (ST).</li> </ul>"},{"location":"contenidos/02_tc3_demo/#replicar-el-proyecto","title":"\ud83d\udd28 Replicar el proyecto","text":"<p>Para replicar la creaci\u00f3n de la soluci\u00f3n completa, seguir este procedimiento:</p> <p>Sugerencia</p> <p>Pulsa en \u27a1\ufe0f para obtener m\u00e1s informaci\u00f3n sobre c\u00f3mo realizar el paso especificado.</p> <ol> <li>Crear una soluci\u00f3n de TwinCAT3 con nombre <code>tc3_demo</code> \u27a1\ufe0f</li> <li> <p>Crear un proyecto PLC con nombre <code>demo_PLC</code> \u27a1\ufe0f</p> <p>Importante</p> <p>En este ejemplo no utilizaremos bloques funcionales (FB) sino que implementaremos toda la funcionalidad directamente en el programa <code>MAIN</code>.</p> </li> <li> <p>Declarar las variables en el programa <code>MAIN</code> \u27a1\ufe0f <pre><code>PROGRAM MAIN\nVAR\n    ContadorCiclos    : UINT; // Variable num\u00e9rica en el espacio de marcas\n    i_Pulsador AT %I* : BOOL; // Variable booleana en la imagen de entrada\n    o_Lampara  AT %Q* : BOOL; // Variable booleana en la imagen de salida\nEND_VAR\n</code></pre></p> </li> <li> <p>Escribir el c\u00f3digo     <pre><code>// Uso de una variable num\u00e9rica (se incrementa con cada ciclo de ejecuci\u00f3n)\nContadorCiclos := ContadorCiclos + 1;\n\n// Uso de variables de entrada y salida booleanas (copia la entrada en la salida)\no_Lampara := i_Pulsador;\n</code></pre></p> </li> <li> <p>Dise\u00f1ar la visualizaci\u00f3n a\u00f1adiendo: \u27a1\ufe0f</p> <p></p> <p>Sugerencia</p> <p>Los colores especificados para los elementos son simplemente un ejemplo, pero pueden ser escogidos libremente.</p> <ol> <li> <p>Rect\u00e1ngulo (Rectangle) para la etiqueta Contador</p> Par\u00e1metros <ul> <li>Texts &gt; Text = Contador</li> </ul> </li> <li> <p>Rect\u00e1ngulo (Rectangle) para el valor de <code>ContadorCiclos</code></p> Par\u00e1metros <ul> <li>Color &gt; Normal state &gt; Frame color = [0, 0, 0]</li> <li>Color &gt; Normal state &gt; Fill color = [255, 255, 255]        </li> <li>Texts &gt; Text = [%d]<ul> <li>Formato estilo printf que indica que se va a sustituir por un n\u00famero entero.</li> </ul> </li> <li>Text variables &gt; Text variable = [<code>MAIN.ContadorCiclos</code>]</li> </ul> </li> <li> <p>Bot\u00f3n (Button) para reiniciar el contador</p> Par\u00e1metros <ul> <li>Texts &gt; Text = [Reinicia]</li> <li>Inputconfiguration <ul> <li>OnMouseClick &gt; Configure &gt; Execute ST-Code = [<code>MAIN.ContadorCiclos := 0;</code>]</li> </ul> </li> </ul> </li> <li> <p>Bot\u00f3n (Button) para el pulsador</p> Par\u00e1metros <ul> <li>Texts &gt; Text = [Pulsador]</li> <li>Inputconfiguration<ul> <li>Tap &gt; Variable = [<code>MAIN.i_Pulsador</code>]</li> </ul> </li> </ul> </li> <li> <p>Rect\u00e1ngulo (Rectangle) para la l\u00e1mpara</p> Par\u00e1metros <ul> <li>Colors &gt; Normal state &gt; Frame color = [0, 64, 0]</li> <li>Colors &gt; Normal state &gt; Fill color = [0, 64, 0]       </li> <li>Colors &gt; Alarm state &gt; Frame color = [0, 128, 0]</li> <li>Colors &gt; Alarm state &gt; Fill color = [0, 128, 0]       </li> <li>Texts &gt; Text = [L\u00e1mpara]</li> <li>Color variables &gt; Toggle color = [<code>MAIN.o_Lampara</code>]</li> </ul> </li> </ol> </li> <li> <p>Compilar el proyecto \u27a1\ufe0f</p> </li> <li>Seleccionar el simulador (<code>UmRT_Default</code>) como controlador \u27a1\ufe0f</li> <li>Activar la configuraci\u00f3n y reiniciar TwinCAT 3 en modo Ejecuci\u00f3n (Run Mode) \u27a1\ufe0f</li> <li>Cargar el c\u00f3digo en el controlador (Login) \u27a1\ufe0f</li> <li>Poner el c\u00f3digo en ejecuci\u00f3n (Start) \u27a1\ufe0f</li> <li>Utilizar la visualizaci\u00f3n integrada en el proyecto PLC para facilitar la prueba:<ol> <li>Reiniciar el contador desde la visualizaci\u00f3n pulsando en el bot\u00f3n Reinicia.</li> <li>Cambiar el valor de la l\u00e1mpara de marcha pulsando el bot\u00f3n de marcha en la visualizaci\u00f3n.</li> <li>Alternativamente, escribe o fuerza las variables deseadas desde TwinCAT 3.</li> </ol> </li> </ol> <p>Ahora vamos a ejecutar el programa en un controlador remoto (por ejemplo, un PLC del laboratorio).</p> <ol> <li> <p>Buscar el controlador en la red, escanear los m\u00f3dulos y probar dos terminales/canales, uno de entrada y otro de salida. \u27a1\ufe0f</p> <p>Sugerencia</p> <p>Abrir la hoja de c\u00e1lculo con la lista de entradas y salidas del sistema FMS200, seleccionar la pesta\u00f1a correspondiente a tu estaci\u00f3n y escoger un pulsador de entre los elementos de entrada y una l\u00e1mpara de entre los elementos de salida.</p> </li> <li> <p>Vincular los terminales/canales correspondiente con las variables de E/S \u27a1\ufe0f</p> <ol> <li>Variable de entrada <code>i_Pulsador</code></li> <li>Variable de salida <code>i_Lampara</code></li> </ol> </li> <li> <p>Activar la configuraci\u00f3n y reiniciar TwinCAT 3 en modo Ejecuci\u00f3n (Run Mode) \u27a1\ufe0f</p> </li> <li>Cargar el c\u00f3digo en el controlador (Login) \u27a1\ufe0f</li> <li>Poner el c\u00f3digo en ejecuci\u00f3n (Start) \u27a1\ufe0f</li> <li>Comprobar que, accionando el pulsador f\u00edsico, se enciende la l\u00e1mpara f\u00edsica.</li> <li>Utilizar la visualizaci\u00f3n integrada en el proyecto PLC para facilitar la prueba:<ul> <li>Comprobar en la visualizaci\u00f3n que, accionando el pulsador f\u00edsico, cambia de estado la l\u00e1mpara.</li> <li> <p>Comprobar en la visualizaci\u00f3n que, accionando el bot\u00f3n de la visualizaci\u00f3n, ni se enciende, ni cambia de estado la l\u00e1mpara.</p> <p>Importante</p> <p>Esto se debe a que la ejecuci\u00f3n del ciclo b\u00e1sico hace que el valor del pulsador se actualice con el valor del pulsador f\u00edsico al inicio de cada ciclo, sobreescribiendo el valor que fija el bot\u00f3n de la visualizaci\u00f3n. </p> </li> </ul> </li> </ol>"},{"location":"contenidos/02_tc3_demo/#descargar-el-ejemplo","title":"\ud83d\ude80 Descargar el ejemplo","text":"<p>Para descargar, compilar y ejecutar este proyecto en el entorno de TwinCAT 3, seguir una de estas dos opciones:</p> <ul> <li>Mediante el Campus Virtual</li> <li>Mediante GIT</li> </ul>"},{"location":"contenidos/02_tc3_demo/#mediante-el-campus-virtual","title":"Mediante el Campus Virtual","text":"<ol> <li>Copiar a tu equipo local el fichero <code>CV &gt; Automatizaci\u00f3n &gt; ejemplos &gt; 1_tc3_demo &gt; tc3_demo.tnzip</code> que hay en la carpeta del campus virtual.</li> <li>Seguir el procedimiento descrito aqu\u00ed para generar la Soluci\u00f3n a partir del fichero.</li> </ol>"},{"location":"contenidos/02_tc3_demo/#mediante-git","title":"Mediante GIT","text":"<ol> <li>Clonar Repositorio:</li> </ol> <pre><code>git clone https://github.com/vetorres-uma/TC3_Demo.git\n</code></pre> <ol> <li>Abrir el Proyecto: abra el archivo <code>.sln</code> (Soluci\u00f3n) ubicado en la carpeta principal utilizando el entorno de ingenier\u00eda TwinCAT XAE (integrado en Visual Studio).</li> <li>Selecci\u00f3n del Controlador: seleccione el simulador (UmRT_Default) o controlador local o remoto (Choose Runtime System).</li> <li>Activaci\u00f3n de Configuraci\u00f3n: en el modo Configuraci\u00f3n, active la configuraci\u00f3n (Activate Configuration) y reinicie TwinCAT en modo Ejecuci\u00f3n (Run Mode).</li> <li>Carga del C\u00f3digo: en el entorno PLC, inicie la sesi\u00f3n y descargue el programa al PLC (Login).</li> <li>Poner el c\u00f3digo en ejecuci\u00f3n: ejecute la l\u00f3gica de control en el controlador (Start). Puede utilizar la visualizaci\u00f3n integrada en el proyecto PLC para facilitar la prueba.</li> </ol>"},{"location":"contenidos/02_tc3_demo/#contribuciones","title":"\ud83e\udd1d Contribuciones","text":"<p>Este proyecto es utilizado con fines educativos y de prueba. Las contribuciones, sugerencias o correcciones de errores son bienvenidas. Por favor, abra un Issue o env\u00ede un Pull Request si deseas contribuir.</p>"},{"location":"contenidos/02_tc3_demo/#autor","title":"\ud83e\uddd1 Autor","text":"<ul> <li>Autor Principal: Victor Torres (@vetorres-uma)</li> <li>Revisor: Manuel Castellano (@mcastellanoquero)</li> <li>Revisor: Francisco \u00c1ngel Moreno (@famoreno)</li> </ul>"},{"location":"contenidos/02_tc3_demo/#licencia","title":"\u2696\ufe0f Licencia","text":"<p>Este proyecto es de c\u00f3digo abierto y est\u00e1 disponible bajo la Licencia P\u00fablica General GNU (GPL).</p> <ul> <li>Consulte el archivo <code>LICENSE.md</code> para m\u00e1s detalles.</li> </ul>"},{"location":"contenidos/03_tc3_carro_basico/","title":"\ud83d\ude83 Carro b\u00e1sico (TwinCAT 3)","text":""},{"location":"contenidos/03_tc3_carro_basico/#descripcion-del-proyecto","title":"\ud83d\udcdd Descripci\u00f3n del Proyecto","text":"<p>El carro va y viene es un m\u00f3vil que se desplaza longitudinalmente entre los extremos izquierdo y derecho de un tramo de v\u00eda.</p> <p></p>"},{"location":"contenidos/03_tc3_carro_basico/#elementos-constituyentes","title":"Elementos constituyentes","text":"<p>La parte operativa del carro b\u00e1sico est\u00e1 constituida por los siguiente dispositivos:</p> <ul> <li>Un motor con dos se\u00f1ales de mando (izquierda y derecha)</li> <li>Un par de sensores finales de carrera (izquierdo y derecho)</li> </ul> <p>La parte de relaci\u00f3n consiste en un panel de operador b\u00e1sico compuesto \u00fanicamente por:</p> <ul> <li>Un pulsador de marcha.</li> <li>Una l\u00e1mpara de marcha.</li> </ul>"},{"location":"contenidos/03_tc3_carro_basico/#descripcion-del-proceso","title":"Descripci\u00f3n del proceso","text":"<p>El funcionamiento del carro b\u00e1sico es como sigue.</p> <ol> <li>El carro se pone en marcha hacia la derecha cuando se acciona el pulsador de marcha. </li> <li>Cuando el carro alcanza el final de carrera derecha invierte el sentido de la marcha.</li> <li> <p>El carro se deteine al alcanzar, de nuevo,  el final de carrera izquierda (posici\u00f3n inicial).</p> </li> <li> <p>Condici\u00f3n inicial: carro detenido sobre el final de carrera izquierda.</p> </li> </ol>"},{"location":"contenidos/03_tc3_carro_basico/#modalidades","title":"Modalidades","text":"<ol> <li>Carro pulsado. El carro inicia un viaje de ida y vuelta, \u00fanicamente, cuando estando en su posici\u00f3n inicial se acciona el pulsador de marcha.</li> <li>Carro temporizado. El carro se detiene durante un determinado tiempo sobre el final de carrera derecha antes de iniciar el camino de regreso hacia su posici\u00f3n inicial.</li> <li>Carro limitado. El carro realiza un determinado n\u00famero de viajes de ida y vuelta (tarea) cada vez que, estando en su posici\u00f3n inicial, se acciona el pulsador de marcha.</li> <li>Carro se\u00f1alizado. La l\u00e1mpara de marcha se enciende de forma permanente para indicar que el carro est\u00e1 en funcionamiento y parpadea para indicar que el carro est\u00e1 en reposo.</li> </ol>"},{"location":"contenidos/03_tc3_carro_basico/#entradas-y-salidas","title":"Entradas y salidas","text":"Nombre Tipo Origen Descripci\u00f3n <code>PM</code> <code>BOOL</code> Input Pulsador de Marcha <code>FCI</code> <code>BOOL</code> Input Final de Carrera Izquierda <code>FCD</code> <code>BOOL</code> Input Final de Carrera Derecha <code>LM</code> <code>BOOL</code> Output Lampara de Marcha <code>MI</code> <code>BOOL</code> Output Marcha Izquierda <code>MD</code> <code>BOOL</code> Output Marcha Derecha"},{"location":"contenidos/03_tc3_carro_basico/#especificacion-funcional","title":"Especificaci\u00f3n funcional","text":"<p>Las siguientes especificaciones funcionales describen el comportamiento del carro (l\u00f3gica de control) de una manera precisa utilizando los diagramas de rel\u00e9s y contactos y el lenguaje GRAFCET.</p> <ul> <li>Diagrama de rel\u00e9s y contactos (PDF)</li> <li>Diagrama grafcet (PDF)</li> </ul>"},{"location":"contenidos/03_tc3_carro_basico/#codigo","title":"C\u00f3digo","text":"<p>Implementa el funcionamiento b\u00e1sico de este \"famoso\" problema de automatizaci\u00f3n del carro va y viene en sus diferentes modalidades (b\u00e1sico, pulsado, temporizado, limitado y se\u00f1alizado).</p> <p>Una de las caracter\u00edstica m\u00e1s relevante de este proyecto did\u00e1ctico es que se muestran diferentes formas de especificar e implementer un problema simple de automatizaci\u00f3n, empleando el lenguaje de especificaci\u00f3n GRAFCET y usando diferentes lenguajes de programaci\u00f3n de la norma IEC 61131-3 (<code>SFC</code> y <code>ST</code>).</p> <ul> <li>GRF \u2192 [SFC / ST]</li> </ul>"},{"location":"contenidos/03_tc3_carro_basico/#requisitos-del-sistema","title":"\ud83d\udcbb Requisitos del Sistema","text":""},{"location":"contenidos/03_tc3_carro_basico/#software","title":"Software","text":"<ul> <li>IDE: Microsoft Visual Studio / TwinCAT 3 XAE (Versi\u00f3n m\u00ednima recomendada: 3.1.4024.x).</li> <li>Lenguajes: Texto Estructurado (ST) y Diagrama de Funciones Secuenciales (SFC).</li> </ul>"},{"location":"contenidos/03_tc3_carro_basico/#replicar-el-proyecto","title":"\ud83d\udd28 Replicar el proyecto","text":""},{"location":"contenidos/03_tc3_carro_basico/#informacion-inicial","title":"Informaci\u00f3n inicial","text":"<p>Importante</p> <p>El proyecto completo que se explica aqu\u00ed se corresponde con la versi\u00f3n se\u00f1alizada del carro va y viene:</p> <ul> <li>El carro inicia un viaje de ida y vuelta, \u00fanicamente, cuando estando en su posici\u00f3n inicial se acciona el pulsador de marcha (se utiliza la detecci\u00f3n del flanco de subida).</li> <li>El carro se detiene durante un determinado tiempo sobre el final de carrera derecha antes de iniciar el camino de regreso hacia su posici\u00f3n inicial.</li> <li>Este proceso de ida y vuelta se realiza un determinado n\u00famero de veces (configurable en la visualizaci\u00f3n) con una sola acci\u00f3n del pulsador de marcha.</li> <li>La l\u00e1mpara de marcha se enciende de forma permanente para indicar que el carro est\u00e1 en funcionamiento y parpadea para indicar que el carro est\u00e1 en reposo.</li> </ul> <p>Para replicar la creaci\u00f3n de la soluci\u00f3n completa, seguir este procedimiento:</p> <p>Sugerencia</p> <p>Pulsa en \u27a1\ufe0f para obtener m\u00e1s informaci\u00f3n sobre c\u00f3mo realizar el paso especificado.</p> <ol> <li>Crear una soluci\u00f3n de TwinCAT3 con nombre <code>tc3_carro_basico</code> \u27a1\ufe0f</li> <li>Crear un proyecto PLC con nombre <code>carro_basico_PLC</code> \u27a1\ufe0f</li> <li>Escoger un lenguaje para la implementaci\u00f3n: ST o SFC.</li> </ol>"},{"location":"contenidos/03_tc3_carro_basico/#version-en-st","title":"Versi\u00f3n en ST","text":"<p>Informaci\u00f3n</p> <p>En esta versi\u00f3n conoceremos c\u00f3mo implementar una m\u00e1quina de estados en lenguaje ST. </p> <p>Para ello, vamos a necesitar una variable espec\u00edfica que guarde el valor actual del estado: <code>Estado</code>, que ser\u00e1 de tipo <code>ENUM</code> y podr\u00e1 tomar los siguientes valores:</p> <p><code>E_Reposo</code>, <code>E_MarchandoDerecha</code>, <code>E_EsperandoDerecha</code>, <code>E_MarchandoIzquierda</code>, <code>E_EvaluandoTarea</code>.</p> <p>N\u00f3tese que estos estados se corresponden con los que tenemos especificados en el GRAFCET del carro se\u00f1alizado.</p> <ol> <li>Crear un bloque funcional con nombre <code>FB_Carro_ST</code> \u27a1\ufe0f</li> <li> <p>Declarar las variables dentro del FB \u27a1\ufe0f</p> <ul> <li>Entrada (se puede especificar su valor en la llamada al FB)</li> </ul> <pre><code>VAR_INPUT\n    ManiobrasSolicitadas     : UINT := 2;\n    TiempoEspera             : TIME := T#2S;\nEND_VAR\n</code></pre> Variable Tipo E/S Descripci\u00f3n ManiobrasSolicitadas UINT no N\u00ba de ciclos \"va-y-viene\" solicitadas para ejecutar. TiempoEspera TIME no Tiempo de espera en lado derecho. <ul> <li>Salida (se puede utilizar su valor fuera del FB)</li> </ul> <pre><code>VAR_OUTPUT\n    ManiobrasPendientes      : UINT;\n    TiempoPendiente          : TIME;\nEND_VAR\n</code></pre> Variable Tipo E/S Descripci\u00f3n ManiobrasPendientes UINT no N\u00ba de ciclos que quedan por realizar TiempoPendiente TIME no Tiempo restante de la espera/temporizaci\u00f3n <ul> <li>Locales (de uso interno al FB)</li> </ul> <pre><code>VAR\n    // Enumeracion de etiquetas para los estados\n    Estado : (E_Reposo, E_MarchandoDerecha, E_EsperandoDerecha, E_MarchandoIzquierda, E_EvaluandoTarea);\n\n    // Utilidades\n    BLK                      : FB_Blink;\n    FlancoPulsadorMarcha     : R_TRIG;\n    TemporizadorEspera       : TON;\n\n    // Entradas\n    i_FinalDerecha    AT %I* : BOOL;\n    i_FinalIzquierda  AT %I* : BOOL := TRUE;\n    i_PulsadorMarcha  AT %I* : BOOL;\n\n    // Salidas\n    o_LamparaMarcha   AT %Q* : BOOL;\n    o_MarchaDerecha   AT %Q* : BOOL;\n    o_MarchaIzquierda AT %Q* : BOOL;\nEND_VAR\n</code></pre> Variable Tipo E/S Descripci\u00f3n Estado ENUM no Estado actual de la m\u00e1quina de estados del carro BLK FB_Blink no Bloque auxiliar para hacer parpadear una se\u00f1al (p.ej. l\u00e1mpara) FlancoPulsadorMarcha R_TRIG no Detector de flanco ascendente del pulsador de marcha TemporizadorEspera TON no Temporizador de retardo para gestionar la espera i_FinalDerecha BOOL E Final de carrera derecha (entrada digital) i_FinalIzquierda BOOL E Final de carrera izquierda (entrada digital) i_PulsadorMarcha BOOL E Pulsador de inicio/marcha del ciclo o_LamparaMarcha BOOL S L\u00e1mpara indicadora de marcha/funcionamiento o_MarchaDerecha BOOL S Orden de movimiento hacia la derecha (salida digital) o_MarchaIzquierda BOOL S Orden de movimiento hacia la izquierda (salida digital) </li> <li> <p>Escribir el c\u00f3digo</p> <p>El c\u00f3digo va a estar formado por tres regiones que se implementan todas en la caja de c\u00f3digo: una para la llamada a las utilidades, otra para la funci\u00f3n de estado y otra para la funci\u00f3n de salida.</p> <ol> <li> <p>Llamada a los FBs de utilidades:</p> <pre><code>// --- UTILIDADES ---\nBLK();\nFlancoPulsadorMarcha(CLK := i_PulsadorMarcha);\nTemporizadorEspera(IN := (Estado = E_EsperandoDerecha), PT := TiempoEspera);\n</code></pre> <ul> <li>Genera la se\u00f1al de parpadeo con <code>BLK</code>.</li> <li>Monitoriza el flanco de subida de <code>i_PulsadorMarcha</code></li> <li>Activa un temporizador de <code>TiempoEspera</code> cuando el estado <code>E_EsperandoDerecha</code> est\u00e9 activo.</li> </ul> </li> <li> <p>Especificaci\u00f3n de la funci\u00f3n de estado que implementa la evoluci\u00f3n de la secuencia:</p> <pre><code>// --- FUNCION DE ESTADO ---\nCASE Estado OF\n    E_Reposo:\n        IF i_FinalIzquierda AND FlancoPulsadorMarcha.Q THEN\n            // Accion a la salida\n            IF ManiobrasPendientes = 0 THEN\n                ManiobrasPendientes := ManiobrasSolicitadas;\n            END_IF;\n\n            Estado := E_MarchandoDerecha;\n        END_IF;\n\n    E_MarchandoDerecha:\n        IF i_FinalDerecha THEN\n            Estado := E_EsperandoDerecha;\n        END_IF;\n\n    E_EsperandoDerecha:\n        // Accion principal\n        TiempoPendiente := TiempoEspera - TemporizadorEspera.ET;\n\n        IF TemporizadorEspera.Q THEN\n            Estado := E_MarchandoIzquierda;\n        END_IF;\n\n    E_MarchandoIzquierda:\n        IF i_FinalIzquierda THEN\n            // Accion a la entrada (siguiente estacion)\n            IF ManiobrasPendientes &gt; 0 THEN\n                ManiobrasPendientes := ManiobrasPendientes - 1;\n            END_IF;\n\n            Estado := E_EvaluandoTarea;            \n        END_IF;\n\n    E_EvaluandoTarea:\n        IF ManiobrasPendientes = 0 THEN\n            Estado := E_Reposo;\n        ELSIF ManiobrasPendientes &gt; 0 THEN\n            Estado := E_MarchandoDerecha;\n        END_IF;\nEND_CASE;\n</code></pre> <ul> <li>En reposo: Pasa a <code>E_MarchandoDerecha</code> si <code>i_FinalIzquierda</code> est\u00e1 activo y se detecta el flanco de <code>i_PulsadorMarcha</code>. Antes de salir de este estado, inicializa el contador <code>ManiobrasPendientes</code> a <code>ManiobrasSolicitadas</code>.</li> <li>Marchando hacia la derecha: Pasa a <code>E_EsperandoDerecha</code> cuando se active el sensor fin de carrera a la derecha <code>i_FinalDerecha</code>.</li> <li>Esperando en la derecha: Calcula el tiempo restante del temporizador y lo asigna a <code>TiempoRestante</code>. Cuando el temporizador termine, pasa a <code>E_MarchandoIzquierda</code>.</li> <li>Marchando hacia la izquierda: Monitoriza el valor del sensor fin de carrera izquierdo <code>i_FinalIzquierda</code>. Cuando se active, decrementa el contador de maniobras pendientes y pasa al estado de evaluaci\u00f3n de la tarea.</li> <li>Evaluando la tarea: Determina si el contador de maniobras pendientes ha llegado a cero, en cuyo caso volvemos a reposo. En caso contrario, repite el proceso \"va-y-viene\" pasando a <code>E_MarchandoDerecha</code>.</li> </ul> </li> <li> <p>Especificaci\u00f3n de la funci\u00f3n de salida que activa las salidas del sistema seg\u00fan el estado activo:</p> <pre><code>// --- FUNCION DE SALIDA ---\no_LamparaMarcha    := ((Estado = E_Reposo) AND BLK.Q) OR (Estado &lt;&gt; E_Reposo);\no_MarchaDerecha    := (Estado = E_MarchandoDerecha);\no_MarchaIzquierda  := (Estado = E_MarchandoIzquierda);\n</code></pre> <ul> <li> <p>Enciende la l\u00e1mpara (<code>o_LamparaMarcha</code>) intermitentemente en el estado de reposo y fija en cualquier otro caso.</p> <p>Informaci\u00f3n</p> <p>N\u00f3tese que <code>((Estado = E_Reposo) AND BLK.Q)</code> genera una se\u00f1al que conmuta intermitentemente cuando el estado de reposo est\u00e9 activo.</p> </li> <li> <p>Activa la salida digital que propicia el movimiento del motor hacia la derecha <code>o_MarchaDerecha</code> en el estado de marcha hacia la derecha.</p> </li> <li>Activa la salida digital que propicia el movimiento del motor hacia la izquierda <code>o_MarchaIzquierda</code> en el estado de marcha hacia la izquierda.</li> </ul> </li> </ol> </li> </ol>"},{"location":"contenidos/03_tc3_carro_basico/#version-en-sfc","title":"Versi\u00f3n en SFC","text":"<p>Informaci\u00f3n</p> <p>En esta versi\u00f3n conoceremos c\u00f3mo implementar una m\u00e1quina de estados en lenguaje gr\u00e1fico SFC.</p> <p>Este lenguaje es muy \u00fatil para implementar m\u00e1quinas de estados de manera sencilla ya que su codificaci\u00f3n explicita directamente la secuencia de estados y sus transiciones.</p> <p>N\u00f3tese la gran similitud entre la especificaci\u00f3n en GRAFCET y la implementaci\u00f3n en SFC.</p> <ol> <li>Crear un bloque funcional con nombre <code>FB_Carro_SFC</code> \u27a1\ufe0f</li> <li> <p>Declarar las variables dentro del FB \u27a1\ufe0f</p> <p>Informaci\u00f3n</p> <p>Las variables para la versi\u00f3n SFC son las mismas que en la versi\u00f3n ST con dos excepciones:</p> <ul> <li>No necesitamos una variable de estado, ya que viene impl\u00edcito en el lenguaje. Adem\u00e1s, TwinCAT 3 asocia una variable booleana a cada estado que indica si \u00e9ste est\u00e1 activo: <code>[nombre_etapa].x</code>.</li> <li>No necesitamos el temporizador ya que TwinCAT 3 incorpora un temporizador asociado a cada etapa, al que se puede acceder mediante el c\u00f3digo <code>[nombre_etapa].t</code>.</li> </ul> </li> <li> <p>Implementamos el c\u00f3digo en SFC \u27a1\ufe0f</p> <p></p> <p>Explicaci\u00f3n del c\u00f3digo (revisar los tipos de acciones \u27a1\ufe0f):</p> <ul> <li> <p>Etapa <code>S0</code>. Se realizan tres acciones asociadas:</p> <ul> <li>Acci\u00f3n continua <code>a_LamparaMarcha</code>: Hace que parpadee cuando <code>S0</code> est\u00e9 activo (<code>S0.x = TRUE</code>) y quede fija en cualquier otra etapa.</li> </ul> <pre><code>BLK();\no_LamparaMarcha := (S0.x AND BLK.Q) OR NOT S0.x;\n</code></pre> <ul> <li>Acci\u00f3n principal <code>a_FlancoMarcha</code>: Realiza la llamada al FB de detecci\u00f3n de flanco de subida del pulsador de marcha. Es en este estado donde queremos que se monitorice este flanco.</li> </ul> <pre><code>FlancoPulsadorMarcha(CLK := i_PulsadorMarcha);\n</code></pre> <ul> <li>Acci\u00f3n memorizada a la salida <code>a_ManiobrasPendientes_Iniciar</code>: Antes de pasar a la siguiente etapa, inicializamos el valor de la variable <code>ManiobrasPendientes</code> al valor solicitado en <code>ManiobrasSolicitadas</code>.</li> </ul> <pre><code>IF ManiobrasPendientes = 0 THEN\n    ManiobrasPendientes := ManiobrasSolicitadas;\nEND_IF\n</code></pre> </li> </ul> <ul> <li>Transici\u00f3n <code>S0</code> \u2192 <code>S1</code>: Cuando est\u00e9 activo el sensor fin de carrera izquierdo y se produzca el flanco de subida del pulsador de marcha.</li> </ul> <ul> <li>Etapa <code>S1</code>. Se realizan dos acciones asociadas:<ul> <li>Acci\u00f3n continua que activa la salida digital correspondiente al movimiento del motor hacia la derecha: <code>o_MarchaDerecha</code>.</li> <li>Acci\u00f3n continua <code>a_LamparaMarcha</code>.</li> </ul> </li> </ul> <ul> <li>Transici\u00f3n <code>S1</code> \u2192 <code>S2</code>: Cuando est\u00e9 activo el sensor fin de carrera derecho.</li> </ul> <ul> <li> <p>Etapa <code>S2</code>. Se realizan dos acciones asociadas:</p> <ul> <li>Acci\u00f3n continua <code>a_LamparaMarcha</code>.</li> <li>Acci\u00f3n principal <code>a_TiempoEspera</code>: Calcula el tiempo que queda por esperar en la posici\u00f3n derecha.</li> </ul> <pre><code>TiempoPendiente := TiempoEspera - S2.t;\n</code></pre> <p>Informaci\u00f3n</p> <p>N\u00f3tese el uso de la expresi\u00f3n <code>S2.t</code>, donde se va almacenando, de forma autom\u00e1tica por TwinCAT 3, el tiempo que la etapa <code>S2</code> est\u00e1 activa.</p> </li> </ul> <ul> <li>Transici\u00f3n <code>S2</code> \u2192 <code>S3</code>: Cuando el tiempo que la etapa <code>S2</code> est\u00e1 activa iguale o supere al tiempo de espera: <code>S2.t &gt;= TiempoEspera</code></li> </ul> <ul> <li>Etapa <code>S3</code>. Se realizan dos acciones asociadas:<ul> <li>Acci\u00f3n continua que activa la salida digital correspondiente al movimiento del motor hacia la izquierda: <code>o_MarchaIzquierda</code>.</li> <li>Acci\u00f3n continua <code>a_LamparaMarcha</code>.</li> </ul> </li> </ul> <ul> <li>Transici\u00f3n <code>S3</code> \u2192 <code>S4</code>: Cuando est\u00e9 activo el sensor fin de carrera izquierdo.</li> </ul> <ul> <li> <p>Etapa <code>S4</code>. Se realizan dos acciones asociadas:</p> <ul> <li>Acci\u00f3n continua <code>a_LamparaMarcha</code>.</li> <li>Acci\u00f3n memorizada a la entrada <code>a_ManiobrasPendientes_Iniciar</code>. Justo al entrar en esta etapa, se decrementa el valor de las <code>ManiobrasPendientes</code>.</li> </ul> <pre><code>IF ManiobrasPendientes &gt; 0 THEN\n    ManiobrasPendientes := ManiobrasPendientes - 1;\nEND_IF\n</code></pre> </li> </ul> <ul> <li>Bifurcaci\u00f3n condicional<ul> <li>Transici\u00f3n <code>S4</code> \u2192 <code>S0</code>: Si el n\u00famero de maniobras pendientes ha llegado a cero, volvemos a la etapa inicial.</li> <li>Transici\u00f3n <code>S4</code> \u2192 <code>S1</code>: Si el n\u00famero de maniobras pendientes a\u00fan no ha llegado a cero, repetimos el proceso.</li> </ul> </li> </ul> </li> <li> <p>Dise\u00f1ar la visualizaci\u00f3n a\u00f1adiendo: \u27a1\ufe0f</p> <p></p> <ol> <li>Rect\u00e1ngulos (Rectangle) para las etiqueta Panel, Maniobras, Tiempos, etc.</li> <li> <p>Rect\u00e1ngulos (Rectangle) editables para introducir el valor de <code>ManiobrasSolicitadas</code> y <code>TiempoEspera</code>.</p> Par\u00e1metros <ul> <li>Texts &gt; Text = <ul> <li>[%d] Formato estilo printf que indica que se va a sustituir por un n\u00famero entero</li> <li>[%t] Formato estilo printf que indica que se va a sustituir por una variable tipo <code>TIME</code> </li> </ul> </li> <li>Text variables &gt; Text variable = <ul> <li>[<code>MAIN.Carro.ManiobrasSolicitadas</code>]</li> <li>[<code>MAIN.Carro.TiempoEspera</code>]</li> </ul> </li> <li>Inputconfiguration <ul> <li>OnMouseClick &gt; Configure &gt; Write a Variable. <ul> <li>Aceptar cuadro de di\u00e1logo por defecto. El valor introducido se escribir\u00e1 en la variable especificada en Text Variable.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Rect\u00e1ngulos (Rectangle) no editables para mostrar el valor de <code>ManiobrasPendientes</code> y <code>TiempoRestante</code>.</p> Par\u00e1metros <ul> <li>Texts &gt; Text = <ul> <li>[%d] Formato estilo printf que indica que se va a sustituir por un n\u00famero entero</li> <li>[%t] Formato estilo printf que indica que se va a sustituir por una variable tipo <code>TIME</code> </li> </ul> </li> <li>Text variables &gt; Text variable = <ul> <li>[<code>MAIN.Carro.ManiobrasPendientes</code>]</li> <li>[<code>MAIN.Carro.TiempoRestante</code>]</li> </ul> </li> </ul> </li> <li> <p>Rect\u00e1ngulos (Rectangle) para las variables booleanas correspondientes a la l\u00e1mpara, pulsador, sensores final de carrera y activaci\u00f3n de motores. Tanto para mostrar su valor como para poder modificarlo.</p> Par\u00e1metros <ul> <li>Texts &gt; Text = [Pulsador], [Lampara], , etc.</li> <li>Color variables &gt; Toggle color = [<code>MAIN.i_PulsadorMarcha</code>], [<code>MAIN.o_Lampara</code>], etc.</li> <li>InputConfiguration<ul> <li>Toggle &gt; Variable: [<code>MAIN.i_PulsadorMarcha</code>], [<code>MAIN.o_Lampara</code>], etc.</li> </ul> </li> </ul> </li> </ol> </li> <li> <p>Declarar la variable <code>Carro</code> de tipo <code>FB_Carro_SFC</code> o <code>FB_Carro_ST</code> en el programa <code>MAIN</code>, seg\u00fan la versi\u00f3n a utilizar.</p> <pre><code>PROGRAM MAIN\nVAR\n    Carro: FB_Carro_SFC; // o Carro: FB_Carro_ST;\nEND_VAR\n</code></pre> </li> <li> <p>Escribir, en la zona de implementaci\u00f3n de <code>MAIN</code>, la llamada al FB del <code>Carro</code>.</p> <pre><code>Carro();\n</code></pre> </li> </ol>"},{"location":"contenidos/03_tc3_carro_basico/#descargar-el-ejemplo","title":"\ud83d\ude80 Descargar el ejemplo","text":"<p>Lenguaje</p> <p>Se proporciona con implementaciones equivalentes en <code>ST</code> y en <code>SFC</code>.</p> <p>Para descargar, compilar y ejecutar este proyecto en el entorno de TwinCAT 3, seguir una de estas dos opciones:</p> <ul> <li>Mediante el Campus Virtual</li> <li>Mediante GIT</li> </ul>"},{"location":"contenidos/03_tc3_carro_basico/#mediante-el-campus-virtual","title":"Mediante el Campus Virtual","text":"<ol> <li>Copiar a tu equipo local el fichero <code>CV &gt; Automatizaci\u00f3n &gt; ejemplos &gt; 2_tc3_carro_basico &gt; tc3_carro_basico.tnzip</code> que hay en la carpeta del campus virtual.</li> <li>Seguir el procedimiento descrito aqu\u00ed para generar la Soluci\u00f3n a partir del fichero.</li> </ol>"},{"location":"contenidos/03_tc3_carro_basico/#mediante-git","title":"Mediante GIT","text":"<ol> <li>Clonar el Repositorio:</li> </ol> <pre><code>git clone https://github.com/vetorres-uma/TC3_Carro_Basico.git\n</code></pre> <ol> <li>Abrir el Proyecto: abra el archivo <code>.sln</code> (Soluci\u00f3n) ubicado en la carpeta principal utilizando el entorno de ingenier\u00eda TwinCAT XAE (integrado en Visual Studio).</li> <li>Selecci\u00f3n del Controlador: seleccione el simulador (UmRT_Default) o controlador local o remoto (Choose Runtime System).</li> <li>Activaci\u00f3n de Configuraci\u00f3n: en el modo Configuraci\u00f3n, active la configuraci\u00f3n (Activate Configuration)) y reinicie TwinCAT en modo Ejecuci\u00f3n (Run Mode).</li> <li>Carga del C\u00f3digo: en el entorno PLC, inicie la sesi\u00f3n y descargue el programa al PLC (Login).</li> <li>Poner el c\u00f3digo en ejecuci\u00f3n: ejecute la l\u00f3gica de control en el controlador (Start). Puede utilizar la visualizaci\u00f3n integrada en el proyecto PLC para facilitar la prueba.</li> </ol>"},{"location":"contenidos/03_tc3_carro_basico/#contribuciones","title":"\ud83e\udd1d Contribuciones","text":"<p>Este proyecto es utilizado con fines educativos. Las contribuciones, sugerencias o correcciones de errores son bienvenidas. Por favor, abra un Issue o env\u00ede un Pull Request si desea contribuir.</p>"},{"location":"contenidos/03_tc3_carro_basico/#autor","title":"\ud83e\uddd1 Autor","text":"<ul> <li>Autor Principal: Victor Torres (@vetorres-uma)</li> <li>Revisor: Francisco \u00c1ngel Moreno (@famoreno)</li> </ul>"},{"location":"contenidos/03_tc3_carro_basico/#licencia","title":"\u2696\ufe0f Licencia","text":"<p>Este proyecto es de c\u00f3digo abierto y est\u00e1 disponible bajo la Licencia P\u00fablica General GNU (GPL).</p> <ul> <li>Consulte el archivo <code>LICENSE.md</code> para m\u00e1s detalles.</li> </ul>"},{"location":"contenidos/01_conceptos/00_leyenda/","title":"00 leyenda","text":"Leyenda Abrev. Significado CD Clic derecho del rat\u00f3n CI Clic izquierdo del rat\u00f3n DCI Doble clic izquierdo del rat\u00f3n TC3 TwinCAT3 CV Campus Virtual FB Bloque funcional (Functional Block)"},{"location":"contenidos/01_conceptos/01_tc3_crear_soluciones/","title":"01 tc3 crear soluciones","text":""},{"location":"contenidos/01_conceptos/01_tc3_crear_soluciones/#crear-soluciones-en-tc3","title":"\ud83c\udfd7\ufe0f Crear soluciones en TC3","text":""},{"location":"contenidos/01_conceptos/01_tc3_crear_soluciones/#crear-proyecto-tc3","title":"Crear proyecto TC3","text":"<ol> <li>Abrir el software <code>Twincat XAE Shell</code>, desde el men\u00fa Inicio de Windows o desde el icono de la barra de programas en segundo plano que hay abajo a la derecha en la barra de tareas.</li> <li> <p>Seleccionar New TwinCAT Project.</p> <p></p> </li> <li> <p>Seleccionar el tipo TwinCAT XAE Project (XML format).</p> <p></p> </li> <li> <p>Darle un nombre a la Soluci\u00f3n, y seleccionar su ubicaci\u00f3n (la que viene por defecto est\u00e1 bien). Dejar marcada la opci\u00f3n Create directory for solution.</p> <p></p> <p>Ejemplo</p> <p><code>TC3_Lampara</code> </p> </li> <li> <p>Por defecto, tanto la Soluci\u00f3n de Visual Studio como el proyecto de TC3 tendr\u00e1n el mismo nombre.</p> </li> </ol> <p>Recomendaci\u00f3n</p> <p>Ocultar las secciones del proyecto que no se van a utilizar: <code>MOTION</code>, <code>SAFETY</code>, <code>C++</code>, <code>VISION</code>, <code>ANALYTICS</code>. Nos quedaremos solo con <code>SYSTEM</code>, <code>PLC</code> e <code>I/O</code>.</p>"},{"location":"contenidos/01_conceptos/01_tc3_crear_soluciones/#crear-proyecto-plc","title":"Crear proyecto PLC","text":"<ol> <li>Una vez creado un proyecto de TC3, procedemos a crear un proyecto PLC.</li> <li>Hacer CD sobre la secci\u00f3n <code>PLC</code> y seleccionar Add New Item.</li> <li> <p>Seleccionar Standard PLC Project, darle un nombre y pulsar Add. </p> <p>Ejemplo</p> <p><code>Lampara_PLC</code></p> </li> <li> <p>En la secci\u00f3n de <code>SYSTEM &gt; Tasks</code> aparecer\u00e1 por defecto una nueva tarea <code>PLC Task</code> con sus par\u00e1metros por defecto (ej. 10 ms de ciclo).</p> </li> <li> <p>En la secci\u00f3n <code>PLC</code> aparece el proyecto con dos secciones nuevas:</p> <ol> <li> <p><code>Project</code></p> <ol> <li><code>External Types</code>. Almacena definiciones de tipos de datos externos que provienen de fuentes externas al PLC.</li> <li><code>References</code>. Listado de referencias a las librer\u00edas utilizadas en el proyecto.</li> <li><code>DUTs</code>. Tipos de Dato de Usuario (Data User Types) (<code>ENUM</code>, <code>STRUCT</code>).</li> <li><code>GVLs</code>. Listas de Variables Globales (Global Variables Lists).</li> <li><code>POUs</code>. Unidades de Organizaci\u00f3n del Programa (Program Organization Units). Programas, bloques funcionales y funciones que implementaremos.</li> <li><code>VISUs</code>. Visualizaciones creadas.</li> <li> <p>Tarea creada (<code>PLCTask</code>) y programa <code>MAIN</code></p> <p></p> </li> </ol> </li> <li> <p><code>Instance</code>. Aqu\u00ed aparecer\u00e1n las variables en las im\u00e1genes de Entrada y Salida.</p> </li> </ol> </li> <li> <p>A partir de aqu\u00ed se puede empezar a implementar el proyecto.</p> </li> </ol>"},{"location":"contenidos/01_conceptos/01_tc3_crear_soluciones/#crear-bloque-funcional","title":"Crear bloque funcional","text":"<ol> <li>Hacer CD sobre la secci\u00f3n <code>POUs</code>.</li> <li>Seleccionar <code>Add \u2192 POU \u2192 Functional Block</code>.</li> <li>Darle un nombre significativo.</li> <li>Seleccionar el lenguaje a utilizar. Normalmente utilizaremos <code>ST</code> o <code>SFC</code>.</li> </ol>"},{"location":"contenidos/01_conceptos/02_tc3_declarar_variables/","title":"02 tc3 declarar variables","text":""},{"location":"contenidos/01_conceptos/02_tc3_declarar_variables/#declaracion-de-variables","title":"\ud83c\udff7\ufe0f Declaraci\u00f3n de variables","text":"<p>Recomendaci\u00f3n</p> <p>Se recomienda utilizar la convenci\u00f3n CamelCase para declarar las variables.</p> <p>Como convenci\u00f3n adicional, a\u00f1adiremos un prefijo <code>i_</code> para aquellas variables que se declaren en la zona de entrada y <code>o_</code> para las de la zona de salida.</p> <ul> <li>Independientemente del lenguaje utilizado para implementar el c\u00f3digo, las variables se declaran de la misma manera.</li> <li>Las variables se declaran en la caja superior de la ventana del bloque funcional creado.</li> <li>La sintaxis para la declaraci\u00f3n de variables es la siguiente:</li> </ul> <pre><code>&lt;NombreVariable&gt; : &lt;tipo&gt; [:=&lt;ValorInicial&gt;]\n</code></pre> <p>Los tipos de datos m\u00e1s utilizados son los siguientes:</p> Tipo de dato Descripci\u00f3n <code>BOOL</code> Variable booleana/binaria. Solo puede valer <code>TRUE</code> o <code>FALSE</code>. <code>INT</code> Entero con signo de 16 bits (-32768 a 32767). <code>UINT</code> Entero sin signo de 16 bits (0 a 65535). <code>FLOAT</code> N\u00famero real en coma flotante (32 bits). Permite decimales. <code>TIME</code> Tipo de dato para representar tiempos o duraciones. <code>R_TRIG</code> Bloque de funci\u00f3n para detectar flanco ascendente (<code>FALSE</code> \u2192 <code>TRUE</code>). <code>TON</code> Temporizador a la conexi\u00f3n (retardo a la activaci\u00f3n). Activa la salida tras un tiempo. <code>ARRAY[x..y] OF ...</code> Conjunto de variables del mismo tipo indexadas entre <code>x</code> e <code>y</code>. <p>Ejemplo</p> <pre><code>// bool\nPulsador: BOOL;\nLuzAmarilla: BOOL := TRUE;\n\n// enteros con y sin signo\nAltura: INT;\nContador: UINT;\nUnidadesSolicitadas: UINT := 10;\n\n// n\u00fameros reales\nTpoSegundos: FLOAT := 1.2;\n\n// tiempo\nTiempoEspera: TIME := T#2s;\nTiempoRestante: TIME;\n\n// bloques funcionales\nFlanco_Pulsador: R_TRIG; // detector de flanco (est\u00e1ndar)\nTemporizador: TON; // temporizador (est\u00e1ndar)\nCoordinador: FB_Coordinador; // bloque funcional definido por el usuario\n\n// arrays\nOcupado: ARRAY[0..3] OF BOOL; // array de cuatro elementos de tipo BOOL; acceso con []\n</code></pre> <ul> <li> <p>La sintaxis de los valores posibles es la siguiente:</p> <ul> <li>Variables booleanas: <code>TRUE</code>, <code>FALSE</code>.</li> <li>Variables enteras: <code>0</code>, <code>1</code>, etc.</li> <li>Variables reales: <code>0.1</code>, <code>2.3</code>, etc.</li> <li> <p>Variables de tiempo: <code>T#&lt;tiempo&gt;</code> donde <code>&lt;tiempo&gt;</code> debe ser del estilo <code>&lt;numero&gt;&lt;unidad&gt;</code>, siendo <code>&lt;unidad&gt;</code> escogido de <code>{s, ms}</code>.</p> <p>Ejemplo</p> <p><code>T#2s</code> (dos segundos)</p> <p><code>T#500ms</code> (quinientos milisegundos).</p> </li> <li> <p>El acceso a los arrays se hace con el \u00edndice entre corchetes. </p> <p>Ejemplo</p> <p><code>Ocupado[1] := TRUE;</code></p> </li> </ul> </li> <li> <p>Ejemplos de llamadas a los bloques funcionales est\u00e1ndar:</p> <p>Ejemplo</p> <p>Detector de flanco: Se activa su salida <code>Flanco_Pulsador.Q</code> cuando la se\u00f1al <code>boton</code> pasa de <code>FALSE</code> a <code>TRUE</code>.     <pre><code>    Flanco_Pulsador(CLK := boton);\n</code></pre></p> <p>Ejemplo</p> <p>Temporizador: Se activa cuando la se\u00f1al <code>start</code> pasa a <code>TRUE</code> y activa su salida <code>Temporizador.Q</code> tras pasar 10s. <pre><code>    Temporizador(IN:=start, PT:=T#10s);\n</code></pre></p> </li> </ul> <p>Las variables en TC3 se declaran dentro de los \u00e1mbitos existentes en el POU correspondiente: locales, entrada y salida.</p>"},{"location":"contenidos/01_conceptos/02_tc3_declarar_variables/#variables-locales","title":"Variables locales","text":"<pre><code>FUNCTIONAL_BLOCK FB_Estacion\nVAR\n    Contador: UINT;\nEND_VAR\n</code></pre> <p>Las variables declaradas aqu\u00ed se pueden utilizar dentro del POU pero no pueden tomar valores de fuera del POU ni se pueden acceder desde fuera del POU.</p>"},{"location":"contenidos/01_conceptos/02_tc3_declarar_variables/#variables-de-entrada","title":"Variables de entrada","text":"<pre><code>FUNCTIONAL_BLOCK FB_Estacion\nVAR_INPUT\n    TiempoEntrada: TIME;\n    TiempoSalida: TIME := T#2s;\nEND_VAR\n</code></pre> <p>Las variables declaradas aqu\u00ed deben ser especificadas al llamar al FB (a no ser que se les de un valor por defecto).</p> <p>Importante</p> <p>No especificarlas en la llamada produce un error de compilaci\u00f3n.</p>"},{"location":"contenidos/01_conceptos/02_tc3_declarar_variables/#variables-de-salida","title":"Variables de salida","text":"<pre><code>FUNCTIONAL_BLOCK FB_Estacion\nVAR_OUTPUT\n    LuzAmarilla: BOOL;\n    LuzVerde: BOOL;\nEND_VAR\n</code></pre> <p>Las variables declaradas aqu\u00ed pueden ser accedidas desde fuera del FB (por ejemplo, desde otro FB que llama a este, o desde el programa <code>MAIN</code>).</p> <pre><code>PROGRAM MAIN\nVAR\n    Estacion: FB_Estacion\n    LuzAmarillaEstacion: BOOL;\nEND_VAR\n------------------\nLuzAmarillaEstacion := Estacion.LuzAmarilla; // esto es v\u00e1lido\n</code></pre> <p>Importante</p> <p>Querer acceder a una variable de un FB que no ha sido declarada como salida produce un error de compilaci\u00f3n.</p>"},{"location":"contenidos/01_conceptos/02_tc3_declarar_variables/#variables-de-entrada-y-salida","title":"Variables de entrada y salida","text":"<pre><code>FUNCTIONAL_BLOCK FB_Estacion\nVAR_IN_OUT\n    Contador: UINT;\nEND_VAR\n</code></pre> <p>Este \u00e1mbito no aparece por defecto al crear un FB pero puede ser a\u00f1adido simplemente escribiendo la secci\u00f3n <code>VAR_IN_OUT ... END_VAR</code>.</p> <p>Las variables declaradas aqu\u00ed deben tomar un valor como entrada al FB y su valor final tras cada ciclo puede ser accedido desde fuera del FB.</p> <p>Combina las condiciones de los \u00e1mbitos de entrada y salida.</p> <ul> <li>En un programa (ej. <code>MAIN</code>) s\u00f3lo disponemos del \u00e1mbito <code>VAR</code>.</li> <li>En un FB, adem\u00e1s del \u00e1mbito <code>VAR</code>, disponemos de los \u00e1mbitos <code>VAR_INPUT</code> y <code>VAR_OUTPUT</code>.</li> </ul>"},{"location":"contenidos/01_conceptos/02_tc3_declarar_variables/#variables-vinculadas-a-la-es","title":"Variables vinculadas a la E/S","text":"<p>Recuerda que la memoria del PLC est\u00e1 estructurada en tres secciones: la imagen de entrada, la imagen de salida y la zona de marcas.</p>"},{"location":"contenidos/01_conceptos/02_tc3_declarar_variables/#zona-de-marcas","title":"Zona de marcas","text":"<p>Aqu\u00ed se guardar\u00e1n aquellas variables que son internas al programa y no van a ser vinculadas con terminales de entrada y salida.</p> <p>Las variables declaradas con la siguiente sintaxis se guardan en la zona de marcas:</p> <pre><code>VAR\n    Pulsador: BOOL;\n    Contador: UINT;\n    Lampara: BOOL;\nEND_VAR\n</code></pre>"},{"location":"contenidos/01_conceptos/02_tc3_declarar_variables/#imagen-de-entrada","title":"Imagen de entrada","text":"<p>Aqu\u00ed se guardar\u00e1n las variables que queremos vincular a las entradas f\u00edsicas del sistema.</p> <p>Su sintaxis a\u00f1ade <code>AT %I*</code> antes de la definici\u00f3n del tipo:</p> <pre><code>VAR\n    i_Pulsador AT %I*: BOOL;\nEND_VAR\n</code></pre> <p>Importante</p> <p>En nuestro trabajo usaremos la convenci\u00f3n de a\u00f1adir un prefijo <code>i_</code> delante de estas variables.</p>"},{"location":"contenidos/01_conceptos/02_tc3_declarar_variables/#imagen-de-salida","title":"Imagen de salida","text":"<p>Aqu\u00ed se guardar\u00e1n las variables que queremos vincular a las salidas f\u00edsicas del sistema.</p> <p>Su sintaxis a\u00f1ade <code>AT %Q*</code> antes de la definici\u00f3n del tipo:</p> <pre><code>VAR\n    o_Lampara AT %Q*: BOOL;\nEND_VAR\n</code></pre> <p>Importante</p> <p>En nuestro trabajo usaremos la convenci\u00f3n de a\u00f1adir un prefijo <code>o_</code> delante de estas variables.</p> <p>Importante</p> <p>Declarar una variable en la imagen de entrada o salida es independiente de que sean entradas o salidas del bloque funcional.</p> <p>Estas declaraciones son completamente correctas.</p> <pre><code>VAR_INPUT\n    Pulsador AT %I*: BOOL;\n    LamparaAmarilla AT %Q*: BOOL;\n    TiempoEspera: TIME;\nEND_VAR\n\nVAR\n    LamparaMarcha AT %Q*: BOOL;\nEND_VAR\n\nVAR_OUTPUT\n    PresenciaPale AT %I*: BOOL;\nEND_VAR\n</code></pre>"},{"location":"contenidos/01_conceptos/03_tc3_crear_duts/","title":"03 tc3 crear duts","text":""},{"location":"contenidos/01_conceptos/03_tc3_crear_duts/#creacion-de-duts","title":"\ud83d\udc6b Creaci\u00f3n de DUTs","text":"<p>Adem\u00e1s de los tipos de datos simples (<code>BOOL</code>, <code>INT</code>, etc.) y los bloques funcionales ya existentes (<code>R_TRIG</code>) o creados por nosotros (<code>FB_Coordinador_ST</code>), en ocasiones podemos necesitar crear tipos de dato que est\u00e1n compuestos por otros tipos de dato. A estos tipos de datos se les denomina tipos de unidad de datos (Data Unit Type, DUT).</p> <p>En nuestros proyectos vamos a poder hacer uso de dos de ellos: </p> <ul> <li>Estructuras (<code>STRUCT</code>)</li> <li>Enumeraciones (<code>ENUM</code>).</li> </ul>"},{"location":"contenidos/01_conceptos/03_tc3_crear_duts/#estructuras","title":"Estructuras","text":"<p>Aglutinan en su interior otros tipos de dato y se definen haciendo CD sobre la carpeta DUTs y escogiendo <code>Add \u2192 DUT</code>:</p> <p></p> <p>Se le da un nombre significativo (se recomienda comenzar con <code>ST</code> como, por ejemplo, <code>ST_PIEZA</code>), se deja marcado Structure y se pulsa en Open.</p> <p>Se abrir\u00e1 una ventana de texto para definir los componentes del tipo de dato:</p> <pre><code>TYPE ST_PIEZA :\nSTRUCT\n    Blanca: BOOL;\n    Baja: BOOL;\n    Tamano: INT;\n    Tiempo: TIME;\nEND_STRUCT\nEND_TYPE\n</code></pre> <p>Para usarlo, se define una variable de ese tipo y se accede a sus componentes mediante el operador <code>.</code> (punto):</p> <pre><code>// Definicion de variables\nVAR\n    Pieza: ST_PIEZA;\n    Baja: BOOL;\nEND_VAR\n--------------------------------\n// Implementacion\nPieza.Blanca := TRUE;\nBaja := (Pieza.Tamano &lt; 12);\nPieza.Tiempo := T#1s;\n</code></pre>"},{"location":"contenidos/01_conceptos/03_tc3_crear_duts/#enumeraciones","title":"Enumeraciones","text":"<p>Una enumeraci\u00f3n (<code>ENUM</code>) es un tipo de datos definido por el usuario compuesto por una serie de componentes separados por comas, tambi\u00e9n llamados valores de enumeraci\u00f3n, que se utiliza para declarar variables definidas por el usuario.</p> <p>Se definen haciendo CD sobre la carpeta DUTs y escogiendo <code>Add \u2192 DUT</code>:</p> <p></p> <p>Se le da un nombre significativo (se recomienda comenzar con <code>E</code> como, por ejemplo,  <code>E_ColorBasic</code>), se deja marcado Enumeration y se pulsa en Open.</p> <p>Se abrir\u00e1 una ventana de texto para definir los componentes del tipo de dato:</p> <pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_ColorBasic :\n(\n    eRed, \n    eYellow,\n    eGreen,\n    eBlue,\n    eBlack\n) // Basic data type is INT, default initialization is eRed\n;\nEND_TYPE\n</code></pre> <p>Una variable definida con el tipo <code>E_ColorBasic</code> es, en realidad, de tipo <code>INT</code> y solo puede tomar los valores definidos en <code>E_ColorBasic</code>: <code>eRed</code>, <code>eYellow</code>, etc.</p> <p>Cada uno de esos valores tiene un valor <code>INT</code> asociado, comenzando por el cero: <code>eRed = 0</code>, <code>eYellow = 1</code>, etc.</p> <p>Para usarlo, se define una variable de ese tipo y se le asigna el valor deseado usando el nombre del tipo de dato Enumeration:</p> <pre><code>// Definicion de variables\nVAR\n    Color: E_ColorBasic;\nEND_VAR\n--------------------------------\n// Implementacion\nColor := E_ColorBasic.eYellow; // asignacion de valor\nIF Color &lt;&gt; E_ColorBasic.eRed THEN // comprobacion de valor\n    [...]\nEND_IF\n</code></pre>"},{"location":"contenidos/01_conceptos/03_tc3_crear_duts/#declaracion-compacta","title":"Declaraci\u00f3n compacta","text":"<p>Importante</p> <p>Este m\u00e9todo se utiliza si el tipo va a ser utilizado solo en un mismo POU. Si se pretende utilizar el tipo enumerado declarado en m\u00e1s de uno, es m\u00e1s conveniente declararlo como DUT siguiendo el procedimiento anterior.</p> <p>Existe otra manera m\u00e1s compacta de declarar una variable de tipo Enumeration. Para ello, basta con declarar el nombre de la variable y los posibles valores que puede tomar. </p> <pre><code>VAR\n    Estado : (E_Reposo, E_MarchandoDerecha, E_MarchandoIzquierda);\nEND_VAR\n</code></pre>"},{"location":"contenidos/01_conceptos/04_tc3_lenguaje_st/","title":"04 tc3 lenguaje st","text":""},{"location":"contenidos/01_conceptos/04_tc3_lenguaje_st/#lenguaje-st","title":"\ud83d\udcc4 Lenguaje ST","text":"<p>Recomendaci\u00f3n</p> <p>Es recomendable acceder a la ayuda y documentaci\u00f3n del lenguaje ST (Structured Text) que ofrece Beckhoff en su portal Infosys.</p>"},{"location":"contenidos/01_conceptos/04_tc3_lenguaje_st/#sintaxis-general","title":"Sintaxis general","text":"<ul> <li>Las instrucciones deben terminar con <code>;</code>.</li> <li>Los comentarios se pueden realizar con <code>//</code> hasta final de l\u00ednea o metiendo el texto entre <code>(*</code> y <code>*)</code>.</li> <li>La asignaci\u00f3n de valores entre variables se realiza con el operador <code>:=</code>.</li> <li>La comparaci\u00f3n de valores se realiza con los operadores <code>=</code>, <code>&lt;&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.</li> <li>Las operaciones l\u00f3gicas se realizan con los operadores <code>AND</code>, <code>OR</code> y <code>NOT</code>.</li> <li>La llamada a los FBs se realiza escribiendo el nombre de la instancia del FB seguido de, entre par\u00e9ntesis, las asignaciones de los valores para las variables de entrada (si las hay), separadas por comas: <code>&lt;nombre_instancia&gt;(var1:=val1, var2:=val2, ...);</code></li> <li> <p>En caso de que no haya ninguna variable de entrada que especificar, simplemente se abre y se cierra par\u00e9ntesis.</p> <p>Ejemplo</p> <p><code>Estacion();</code></p> <p><code>Lampara(TiempoEncedido:=T#2s);</code></p> </li> </ul>"},{"location":"contenidos/01_conceptos/04_tc3_lenguaje_st/#estructuras-de-control","title":"Estructuras de control","text":"<ul> <li>Las estructuras de control b\u00e1sicas son:<ul> <li>Condicionales (<code>if</code>, <code>case</code>)     <pre><code>IF &lt;condition&gt; THEN\n    &lt;statements&gt;\nELSIF &lt;condition&gt; THEN\n    &lt;statements&gt;\nELSE\n    &lt;statements&gt;\nEND_IF;\n\nCASE &lt;expression&gt; OF\n    &lt;value&gt;, &lt;value&gt;, \u2026, &lt;value&gt;: &lt;statements&gt;\nELSE\n    &lt;statements&gt;\nEND_CASE;\n</code></pre></li> <li>Bucles (<code>for</code>, <code>while</code>, <code>repeat</code>)     <pre><code>FOR &lt;variable&gt; := &lt;expression&gt; TO &lt;expression&gt; BY &lt;expression&gt; DO\n    &lt;statements&gt;\nEND_FOR;\n\nWHILE &lt;condition&gt; DO\n    &lt;statements&gt;\nEND_WHILE;\n\nREPEAT\n    &lt;statement&gt;\nUNTIL &lt;condition&gt;\nEND_REPEAT;\n</code></pre></li> </ul> </li> </ul>"},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/","title":"05 tc3 lenguaje sfc","text":""},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/#lenguaje-sfc","title":"\u2935\ufe0f Lenguaje SFC","text":""},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/#reglas-sintacticas","title":"Reglas sint\u00e1cticas","text":"<ul> <li>Los nombres de las etapas en SFC (Sequential Function Chart) no pueden empezar por un n\u00famero. Tampoco pueden tener espacios, puntos u otros caracteres especiales como e\u00f1es, interrogaciones, etc. S\u00ed permite guiones bajos.</li> <li>No puede haber dos etapas consecutivas ni dos transiciones consecutivas. Hay que tener especial atenci\u00f3n a esto cuando se produzcan bifurcaciones o saltos.</li> </ul>"},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/#anadir-etapa-transicion","title":"A\u00f1adir etapa / transici\u00f3n","text":"<ul> <li>Hacer CD sobre la etapa donde queramos introducir una nueva y seleccionar Add step-transition o Add step-transition after, dependiendo de si queremos a\u00f1adirla antes o despu\u00e9s, respectivamente, de la etapa seleccionada.</li> </ul> <p>Importante</p> <p>Comprobar que no quedan dos etapas o dos transiciones consecutivas. En caso contrario, borrar aquello que no sirva (CI sobre \u00e9l y pulsar Supr).</p>"},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/#asociar-acciones-a-etapas","title":"Asociar acciones a etapas","text":""},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/#accion-continua","title":"Acci\u00f3n continua","text":"<p>Las acciones continuas se ejecutan de manera continuada mientras el sistema est\u00e1 en la etapa asociada. Esto nos va a permitir:</p> <ul> <li>Activar una se\u00f1al booleana durante todo el tiempo que la etapa est\u00e9 activa. </li> <li>Ejecutar una acci\u00f3n m\u00e1s compleja asociada al FB de manera continua mientras la etapa est\u00e9 activa.</li> </ul> <p>El procedimiento para su creaci\u00f3n es el siguiente:</p> <ul> <li>Hacer CD sobre la etapa a la que queramos asociar una acci\u00f3n no memorizada (o continua) y seleccionar Insert action association o Insert action association after, dependiendo de si queremos insertarla antes o despu\u00e9s de las ya existentes (si las hay).</li> <li>En la caja de la acci\u00f3n aparece en primer lugar el modificador (por defecto <code>N</code>, que significa \"No memorizada\") y en segundo lugar el hueco donde debemos poner la acci\u00f3n a realizar.</li> </ul>"},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/#senal-booleana","title":"Se\u00f1al booleana","text":"<p>Si queremos activar una se\u00f1al booleana, bastar\u00e1 con escribir su nombre en la caja de acci\u00f3n.</p> <p></p> <p>Existen varios tipos de modificadores de acciones:</p> C\u00f3digo Tipo Descripci\u00f3n <code>N</code> No memorizada (continua) Se ejecuta/activa mientras la etapa est\u00e9 activa. <code>R0</code> Reinicio La acci\u00f3n se desactiva. <code>S0</code> Activaci\u00f3n Se ejecuta cuando se activa la etapa y contin\u00faa activa aunque la etapa se desactive. <code>L</code> Limitada Se ejecuta cuando se activa la etapa y se desactiva cuando la etapa se desactiva o se alcanza el tiempo especificado. <code>D</code> Retrasada Se ejecuta un tiempo despu\u00e9s de que se active la etapa y se desactiva cuando la etapa se desactiva. <code>P</code> Pulsada Se ejecuta dos veces: cuando se activa la etapa y una vez m\u00e1s en el ciclo siguiente. <code>SD</code> Activaci\u00f3n con retardo Se activa aunque la etapa ya no est\u00e9 activa. <code>DS</code> Retardo de activaci\u00f3n Se activa solo si la etapa permanece activa. <code>SL</code> Activaci\u00f3n limitada Activaci\u00f3n con duraci\u00f3n limitada. <p>Importante</p> <p>Usaremos, por defecto, las acciones no memorizadas, aunque se pueden usar las otras si tiene sentido para el proyecto.</p>"},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/#accion-compleja","title":"Acci\u00f3n compleja","text":"<p>Si, por el contrario, lo que queremos asociar a esta etapa es una acci\u00f3n compleja, tendremos que realizar el siguiente procedimiento:</p> <ul> <li> <p>A\u00f1adir una acci\u00f3n haciendo CD sobre el FB donde queremos usar la acci\u00f3n y seleccionar <code>Add &gt; Action...</code></p> <p></p> </li> <li> <p>Especificar el nombre de la acci\u00f3n que queramos y seleccionar el lenguaje en el que la vamos a implementar.</p> <p></p> <p>Sugerencia</p> <p>En nuestro trabajo tomaremos la convenci\u00f3n de a\u00f1adir el prefijo <code>a_</code> a las acciones que creemos de este modo.</p> </li> <li> <p>Escribir el c\u00f3digo de la acci\u00f3n, como por ejemplo:</p> <pre><code>BLK();\no_LamparaMarcha := (S0.x AND BLK.Q) OR NOT S0.x;\n</code></pre> </li> <li> <p>Asociarlo a una etapa en la caja de acci\u00f3n cont\u00ednua.</p> <p></p> </li> <li> <p>A partir de este momento, el c\u00f3digo de la acci\u00f3n se ejecutar\u00e1 de manera continua (en cada ciclo b\u00e1sico del PLC) mientras la etapa asociada est\u00e9 activa.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/#accion-de-entrada-o-salida","title":"Acci\u00f3n de entrada o salida","text":"<p>Tambi\u00e9n podemos crear acciones con activaci\u00f3n a la entrada o a la salida de una etapa. Estas acciones se implementan en cualquiera de los lenguajes de la norma y permiten realizar acciones que se ejecutan solo una vez durante la etapa, en lugar de hacerse de manera continua.</p>"},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/#a-la-entrada","title":"A la entrada","text":"<ul> <li>Las acciones con activaci\u00f3n a la entrada se ejecutan solo una vez inmediatamente despu\u00e9s de entrar en la etapa donde se asocian. Posteriormente se comprueba si la condici\u00f3n de transici\u00f3n para pasar a la siguiente etapa es cierta o no.</li> <li>Normalmente usaremos estas acciones para inicializar variables memorizadas, actualizar contadores, etc.</li> <li>Para crear una de este tipo, hacer CD sobre la etapa donde la queremos asociar y seleccionar Add entry action.</li> <li> <p>Aparece un popup donde se nos pregunta por el nombre que le queremos poner y el lenguaje a utilizar. Se recomienda dejar el nombre por defecto (<code>S0_entry</code> en la figura) ya que nos indica en qu\u00e9 etapa est\u00e1 y de qu\u00e9 tipo es.</p> <p></p> </li> <li> <p>En nuestros proyectos, estas acciones siempre ser\u00e1n implementadas en <code>ST</code>, pero podr\u00edan ser codificadas en cualquier otro lenguaje de la norma.</p> </li> <li> <p>Una vez creada, se representa en el programa <code>SFC</code> como un cuadrado con una E en la esquina inferior izquierda de la etapa.</p> <p></p> </li> </ul>"},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/#a-la-salida","title":"A la salida","text":"<ul> <li>Las acciones con activaci\u00f3n a la salida se ejecutan solo una vez inmediatamente antes de pasar a la siguiente etapa. Esto implica que antes de que se ejecute esta acci\u00f3n, la condici\u00f3n de transici\u00f3n para pasar a la siguiente etapa debe ser cierta.</li> <li>Normalmente usaremos estas acciones para inicializar variables memorizadas, actualizar contadores, etc.</li> <li>Para crear una de este tipo, hacer CD sobre la etapa donde la queremos asociar y seleccionar Add exit action.</li> <li> <p>Aparece un popup donde se nos pregunta por el nombre que le queremos poner y el lenguaje a utilizar. Se recomienda dejar el nombre por defecto (<code>S0_exit</code> en la figura) ya que nos indica en qu\u00e9 etapa est\u00e1 y de qu\u00e9 tipo es.</p> <p></p> <p>Importante</p> <p>En nuestros proyectos, estas acciones siempre ser\u00e1n en <code>ST</code>, pero podr\u00edan ser implementadas en cualquier otro lenguaje de la norma.</p> </li> <li> <p>Una vez creada, se representa en el programa <code>SFC</code> como un cuadrado con una X en la esquina inferior derecha de la etapa.        </p> </li> </ul> <p>Importante</p> <p>Nada impide que una etapa tenga asociadas una o varias acciones no memorizadas, una con activaci\u00f3n a la entrada y otra con activaci\u00f3n a la salida.</p>"},{"location":"contenidos/01_conceptos/05_tc3_lenguaje_sfc/#accion-principal","title":"Acci\u00f3n principal","text":"<p>Existe un cuarto tipo de acciones que podemos utilizar: las acciones principales. Estas acciones tambi\u00e9n se asocian a una etapa y se ejecutan de manera continua durante todo el tiempo que la etapa est\u00e9 activa.</p> <p>El procedimiento de creaci\u00f3n de estas acciones es el mismo que el indicado aqu\u00ed pero, en lugar de introducir el nombre de la acci\u00f3n en la caja de acci\u00f3n, lo introduciremos en el campo <code>Main Action</code> dentro de las propiedades de la etapa.</p> <p></p> <p>Una vez asociada a la etapa, aparece representada en el diagrama SFC con un tri\u00e1ngulo oscuro en la esquina superior derecha de la misma.</p> <p></p> <p>Importante</p> <p>Conceptualmente no hay diferencia sustancial con las acciones complejas utilizadas en las cajas de acci\u00f3n, pero tomaremos la convenci\u00f3n de utilizar este tipo de acciones cuando las variables involucradas no est\u00e9n relacionadas con las E/S hardware de nuestro sistema y las acciones en la caja de acci\u00f3n en caso contrario.</p>"},{"location":"contenidos/01_conceptos/06_tc3_estructuras_evolucion/","title":"06 tc3 estructuras evolucion","text":""},{"location":"contenidos/01_conceptos/06_tc3_estructuras_evolucion/#estructuras-de-evolucion","title":"\ud83d\udd00 Estructuras de evoluci\u00f3n","text":""},{"location":"contenidos/01_conceptos/06_tc3_estructuras_evolucion/#secuencia-basica","title":"Secuencia b\u00e1sica","text":"<ul> <li> <p>Una secuencia b\u00e1sica se compone de una sucesi\u00f3n lineal de etapas y transiciones, donde las primeras se van a ir ejecutando en secuencia conforme las condiciones asociadas a las segundas se vayan cumpliendo.</p> </li> <li> <p>Normalmente, al final de la secuencia se producir\u00e1 un salto hacia atr\u00e1s (o el inicio) en el programa.</p> <p></p> </li> <li> <p>Para insertar un salto detr\u00e1s de una transici\u00f3n, hay que hacer CD sobre la transici\u00f3n y seleccionar Insert jump after. Solo hay que indicar el nombre de la etapa a la que queremos saltar.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/06_tc3_estructuras_evolucion/#bifurcacion","title":"Bifurcaci\u00f3n","text":"<ul> <li> <p>Tras una etapa podemos realizar una bifurcaci\u00f3n en distintas ramas en funci\u00f3n de distintas condiciones. Esto nos permite dirigir la secuencia por un camino si ocurre un evento y por otros distintos si ocurren otros eventos.</p> </li> <li> <p>En el ejemplo de la figura, si la etapa <code>Init</code> est\u00e1 activa y se activa <code>Execute</code>, el programa evolucionar\u00e1 por la rama de la izquierda llegando a <code>S0</code>. Si lo que se activa es <code>Restore</code>, el programa evolucionar\u00e1 por la derecha pasando a <code>Sr</code> y, una vez se active <code>Restaurado</code>, la secuencia pasar\u00e1 a <code>S0</code>.</p> <p></p> </li> <li> <p>Para realizar una bifurcaci\u00f3n, hacer CD sobre la transici\u00f3n donde se quiera hacer la bifurcaci\u00f3n (<code>Execute</code> en el ejemplo) y seleccionar Insert branch right.</p> </li> <li> <p>Nada impide que se pueda hacer una bifurcaci\u00f3n con m\u00e1s de dos ramas.</p> </li> <li> <p>Es recomendable que las condiciones de la bifurcaci\u00f3n sean excluyentes pero nada impide que no lo sean. El programa tomar\u00e1 el camino de la primera transici\u00f3n cuya condici\u00f3n sea verdadera de izquierda a derecha.</p> </li> <li> <p>Si ocurriera que varias o todas las condiciones son verdaderas a la vez, el programa evolucionar\u00e1 por la rama de la izquierda. Aunque esto puede ser \u00fatil en algunos casos, esto suele indicar que hay un mal dise\u00f1o en el programa.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/06_tc3_estructuras_evolucion/#paralelismo","title":"Paralelismo","text":"<ul> <li> <p>Si queremos que el programa evolucione por dos secuencias en paralelo (se ejecutan simult\u00e1neamente) podemos incluir un paralelismo en el c\u00f3digo.</p> </li> <li> <p>En el ejemplo de la figura, si la etapa <code>Init</code> est\u00e1 activa y se activa <code>Execute</code>, el programa evolucionar\u00e1 por ambas ramas a la vez, activando los estados <code>S0</code> y <code>Sr</code> de manera simult\u00e1nea (y por tanto, <code>LuzRoja</code> y <code>Restaura</code>).</p> <p></p> </li> <li> <p>En la transici\u00f3n con condici\u00f3n <code>NOT Pulsador OR S0.t&gt;T#5s</code> se produce un punto de sincronizaci\u00f3n ya que, para que el programa evolucione a <code>S1</code> debe ocurrir que <code>S0</code> y <code>Sr2</code> est\u00e9n activas y, adem\u00e1s, que la condici\u00f3n <code>NOT Pulsador OR S0.t&gt;T#5s</code> sea cierta. Por tanto, podemos decir que el programa esperar\u00e1 hasta que termine la rama de la derecha antes de evolucionar.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/07_tc3_crear_visualizacion/","title":"07 tc3 crear visualizacion","text":""},{"location":"contenidos/01_conceptos/07_tc3_crear_visualizacion/#crear-visualizacion","title":"\ud83d\udda5\ufe0f Crear visualizaci\u00f3n","text":"<ul> <li> <p>Hacer CD sobre la secci\u00f3n <code>VISUs</code>.</p> </li> <li> <p>Seleccionar <code>Add \u2192 Visualization</code> y pulsar en Open en la ventana popup.</p> <p></p> </li> <li> <p>En la parte derecha de la pantalla aparecer\u00e1 la secci\u00f3n <code>Toolbox</code> donde, en la secci\u00f3n <code>Basic</code> aparecen las formas b\u00e1sicas. Arrastrar a la visualizaci\u00f3n los elementos que se quieran.</p> </li> </ul> <p>Importante</p> <p>Si no aparece la secci\u00f3n, mostrarlo entrando en el Men\u00fa <code>View \u2192 Toolbox</code></p> <p>Recomendaci\u00f3n</p> <p>Se recomienda utilizar rect\u00e1ngulos para crear botones tanto para las entradas como para las salidas.</p>"},{"location":"contenidos/01_conceptos/07_tc3_crear_visualizacion/#botones-para-cambiar-valores-de-variables","title":"Botones para cambiar valores de variables","text":"<ul> <li> <p>Dibujar un rect\u00e1ngulo con el tama\u00f1o deseado.</p> </li> <li> <p>Escribir dentro la etiqueta que queramos que aparezca en el bot\u00f3n.</p> </li> <li> <p>Introducir la variable de tipo <code>BOOL</code> que queremos asociar a dicho bot\u00f3n. Dependiendo del comportamiento que queramos que tenga el bot\u00f3n, esta variable se introduce en una secci\u00f3n distinta dentro de <code>Properties \u2192 Input Configuration</code> (la pesta\u00f1a <code>Properties</code> aparece a la derecha, normalmente combinada con <code>Toolbox</code>).</p> <ul> <li> <p>Si queremos que la variable cambie de valor mientras se pulsa el bot\u00f3n con el rat\u00f3n pero vuelva a su valor anterior una vez soltado el rat\u00f3n, introduciremos la variable en la secci\u00f3n <code>Tap</code>:</p> <p></p> </li> <li> <p>Si queremos que la variable cambie de valor cada vez que pulsemos el bot\u00f3n lo introduciremos en la secci\u00f3n <code>Toggle</code> (el valor conmutar\u00e1 entre <code>TRUE</code> y <code>FALSE</code>):</p> <p></p> </li> </ul> </li> </ul>"},{"location":"contenidos/01_conceptos/08_tc3_importar_exportar/","title":"08 tc3 importar exportar","text":""},{"location":"contenidos/01_conceptos/08_tc3_importar_exportar/#exportar-e-importar","title":"\ud83d\udd04 Exportar e importar","text":"<ol> <li>Podemos exportar <code>POUs</code> y <code>VISUs</code> desde una soluci\u00f3n de TC3 e importarla de nuevo en otra distinta. De esta manera podemos reutilizar c\u00f3digo de distintas proyectos.</li> <li>Para realizar esto, en la soluci\u00f3n origen, simplemente hay que hacer CD sobre el <code>POU</code> o <code>VISU</code> a exportar y seleccionar Export to ZIP. Se selecciona donde guardar el archivo exportado y se pulsa Save.</li> <li>Posteriormente, en la soluci\u00f3n destino, hacer CD sobre la carpeta <code>POU</code> o <code>VISU</code> y seleccionar Import from ZIP. Se busca el archivo correspondiente y se pulsa OK.</li> </ol>"},{"location":"contenidos/01_conceptos/09_tc3_guardar_mover/","title":"09 tc3 guardar mover","text":""},{"location":"contenidos/01_conceptos/09_tc3_guardar_mover/#guardar-y-mover-proyectos","title":"\ud83d\udcbe Guardar y mover proyectos","text":"<p>Importante</p> <p>Se ha detectado que el sincronizar la carpeta del proyecto usando servicios como Google Drive est\u00e1 produciendo problemas a la hora de poder abrir los proyectos. Posiblemente esto se deba a que algunos ficheros no son sincronizados correctamente por Drive (por motivos desconocidos), lo que lleva a que, a la hora de abrir el proyecto, no se carguen los ficheros necesarios. </p> <p>Se recomienda, por tanto, no usar este m\u00e9todo sino alguno de los otros.</p>"},{"location":"contenidos/01_conceptos/09_tc3_guardar_mover/#usando-la-carpeta-completa","title":"Usando la carpeta completa","text":"<ol> <li>Es la manera m\u00e1s sencilla de llevarse un proyecto desde un equipo a otro.</li> <li> <p>Solo hay que copiar la carpeta ra\u00edz en un pendrive y pegar la carpeta en el equipo destino.</p> <p></p> </li> <li> <p>Posteriormente, hacer DCI sobre el fichero de Solution (<code>.sln</code>) para que se abra de nuevo en TC3.</p> </li> </ol> <p>Importante</p> <p>Si la carpeta ha sido comprimida para ser trasladada, hay que asegurarse de haber descomprimido la carpeta completa en el destino antes de abrir el proyecto.</p>"},{"location":"contenidos/01_conceptos/09_tc3_guardar_mover/#guardando-como-tnzip","title":"Guardando como <code>.tnzip</code>","text":"<p>Importante</p> <p>La entrega final del proyecto deber\u00e1 seguir este procedimiento.</p> <ol> <li>Este proceso genera el m\u00ednimo tama\u00f1o posible para trasladar un proyecto.</li> <li>Seleccionar <code>File \u2192 Save [nombre_del_proyecto] as Archive...</code>.</li> <li>Seleccionar d\u00f3nde guardar el proyecto, darle un nombre y asegurarse de que el formato es de tipo <code>.tnzip</code>.</li> </ol>"},{"location":"contenidos/01_conceptos/09_tc3_guardar_mover/#abrir-un-fichero-tnzip","title":"Abrir un fichero <code>.tnzip</code>","text":"<p>Una vez movido el fichero <code>.tnzip</code> al equipo destino, para volver a abrir el proyecto, seguimos este procedimiento:</p> <ul> <li>Abrir TC3.</li> <li>Seleccionar <code>File \u2192 Open \u2192 Solution from Archive...</code>.</li> <li>Buscar el archivo <code>.tnzip</code>.</li> <li>Seleccionar (o crear si no existe) la carpeta donde queremos que se genere la Solution.</li> </ul> <p>Sugerencia</p> <p>En principio, se puede seleccionar siempre la misma carpeta cada vez que se repita este procedimiento.</p> <p>Importante</p> <p>Si al abrir el proyecto de nuevo y compilar obtienes errores no relacionados con el c\u00f3digo que antes no ten\u00edas:</p> <ul> <li>Cambiar el tipo de proyecto a TwinCAT RT (x86)</li> <li>Recompilar</li> <li>Volver a cambiar a TwinCAT RT (x64)</li> <li>Volver a recompilar</li> </ul>"},{"location":"contenidos/01_conceptos/09_tc3_guardar_mover/#usando-git","title":"Usando GIT","text":"<p>TwinCAT3, al estar basado en Visual Studio, tiene compatibilidad directa con GitHub.  Se recomienda seguir el tutorial en este video:</p> <p>PLC Programming using TwinCAT 3 - Version control</p>"},{"location":"contenidos/01_conceptos/10_tc3_convenciones/","title":"10 tc3 convenciones","text":""},{"location":"contenidos/01_conceptos/10_tc3_convenciones/#convenciones-de-nombres","title":"\ud83d\udcdd Convenciones de nombres","text":"<p>Se recomienda llamar a todos los elementos del proyecto con el nombre adecuado desde el principio, ya que renombrar a posteriori puede acarrear problemas derivados del acceso a elementos cuya ruta ha cambiado. No obstante, si es necesario renombrar los elementos, el procedimiento es como sigue.</p>"},{"location":"contenidos/01_conceptos/10_tc3_convenciones/#soluciones","title":"Soluciones","text":"<p>Se recomienda llamar a las soluciones de TC3 de la misma forma que los Proyectos de TC3.</p> <p>Para renombrarlo una vez creado:</p> <ol> <li> <p>CD sobre el nombre de la soluci\u00f3n y seleccionar Rename.</p> <p></p> </li> <li> <p>Escribir el nuevo nombre.</p> </li> </ol>"},{"location":"contenidos/01_conceptos/10_tc3_convenciones/#proyectos-twincat3","title":"Proyectos TwinCAT3","text":"<ul> <li> <p>Se recomienda llamar a los proyectos TC3 de la siguiente forma:</p> <ul> <li> <p>Para los ejemplos: <code>TC3_[nombre]</code>   donde el nombre debe ser algo significativo.</p> <p>Ejemplo</p> <p><code>TC3_Lampara</code></p> <p><code>TC3_Carro</code></p> </li> <li> <p>Para los trabajos finales: <code>[codigo]_TC3_G[grupo]</code>   donde <code>codigo</code> debe escogerse seg\u00fan la asignatura (<code>AIM</code>, <code>AIE</code>, <code>SR</code>, etc.) y <code>grupo</code> debe ser el n\u00famero del grupo con dos d\u00edgitos (<code>01</code>, <code>02</code>, ...).</p> <p>Ejemplo</p> <p><code>AIM_TC3_G01</code></p> <p><code>SR_TC3_G12</code></p> </li> <li> <p>C\u00f3digos de las asignaturas:</p> C\u00f3digo Asignatura AIM Automatizaci\u00f3n Industrial de GIERM AIE Automatizaci\u00f3n Industrial de GIEI o GIEI+IEL SR Sistemas Robotizados de GITI </li> <li> <p>Para renombrarlo una vez creado:</p> <ul> <li> <p>CD sobre el nombre del proyecto TC3 y seleccionar Rename.</p> <p></p> </li> <li> <p>Escribir el nuevo nombre.</p> </li> </ul> </li> </ul> </li> </ul>"},{"location":"contenidos/01_conceptos/10_tc3_convenciones/#proyectos-plc","title":"Proyectos PLC","text":"<ul> <li> <p>Se recomienda llamar a los proyectos PLC de la forma <code>[nombre]_PLC</code> para los ejemplos o <code>[estacion]_[nivel]_PLC</code> para los trabajos, donde el nombre debe ser algo significativo.</p> <p>Ejemplo</p> <p><code>Lampara_PLC</code></p> <p><code>FMS201_Monolitico_PLC</code></p> </li> <li> <p>Para renombrarlo una vez creado:</p> <ol> <li> <p>CD sobre el nombre del proyecto PLC y seleccionar Rename.</p> <p></p> </li> <li> <p>Escribir el nuevo nombre.</p> </li> <li> <p>Aparecer\u00e1 un aviso indicando que si se cambia el nombre del proyecto no se van a poder hacer cambios online (en caso de que se est\u00e9 ejecutando). CI en S\u00ed.</p> <p></p> </li> <li> <p>Tras unos segundos, el proyecto PLC habr\u00e1 cambiado de nombre.</p> </li> <li>Importante: Puede ocurrir que, tras el cambio de nombre, al hacer CI sobre el proyecto, salga un aviso de error por no encontrar el nombre anterior. Esto se debe solucionar haciendo CI sobre <code>Build \u2192 Rebuild Solution</code>.</li> </ol> </li> </ul>"},{"location":"contenidos/01_conceptos/10_tc3_convenciones/#bloques-funcionales","title":"Bloques Funcionales","text":"<ul> <li>Se recomienda llamar a los bloques funcionales de la forma <code>FB_[nombre]_[lenguaje]</code>, donde el nombre debe ser algo significativo.</li> <li> <p>Los lenguajes suelen ser:</p> <ul> <li><code>ST</code> (Structured Text)</li> <li><code>SFC</code> (Sequential Function Chart)</li> </ul> <p>Ejemplo</p> <p><code>FB_Estacion_ST</code></p> <p><code>FB_Coordinador_ST</code></p> <p><code>FB_Alimentador_SFC</code></p> </li> <li> <p>Para renombrarlo una vez creado:</p> <ol> <li>CD sobre el nombre del FB y seleccionar Rename.</li> <li>Escribir el nuevo nombre.</li> <li> <p>Aparecer\u00e1 un aviso indicando que se van a adaptar todas las referencias en el proyecto. Pulsar en Yes.</p> <p></p> </li> <li> <p>Aparecer\u00e1 una ventana mostrando todos los cambios que se van a realizar. Pulsar en OK.</p> <p></p> </li> </ol> </li> </ul>"},{"location":"contenidos/01_conceptos/10_tc3_convenciones/#variables","title":"Variables","text":"<ul> <li>Se recomienda llamar a las variables con nombres significativos.</li> <li>Si las variables se van a asociar con los terminales de entrada y salida, es obligatorio llamarlas con el nombre indicado en la columna Variable de la tabla de E/S.</li> <li>Para renombrar una variable y que ese cambio se corrija en todas las referencias que se hagan a la misma en el proyecto, hay que hacer CD sobre el nombre de la variable y seleccionar <code>Refactoring \u2192 Rename</code>.</li> <li> <p>Aparecer\u00e1 un popup donde se debe indicar el nuevo nombre.</p> <p></p> </li> <li> <p>Aparecer\u00e1 una ventana mostrando todos los cambios que se van a realizar. Pulsar en OK.</p> <p></p> </li> </ul>"},{"location":"contenidos/01_conceptos/11_tc3_ejecutar_programa/","title":"11 tc3 ejecutar programa","text":""},{"location":"contenidos/01_conceptos/11_tc3_ejecutar_programa/#ejecutar-programa","title":"\u25b6\ufe0f Ejecutar programa","text":"<p>Una vez el programa est\u00e1 implementado (independientemente del lenguaje utilizado):</p> <ul> <li>Compilar el proyecto: Men\u00fa <code>Build \u2192 Build [nombre del proyecto]</code>.</li> <li>Asegurarse de que no hay errores.</li> <li>Si has declarado variables en las im\u00e1genes de entrada y/o salida:     <ul> <li>Comprobar que las variables aparecen en la zona de la instancia.     </li> </ul> </li> </ul>"},{"location":"contenidos/01_conceptos/11_tc3_ejecutar_programa/#seleccionar-el-controlador","title":"Seleccionar el controlador","text":"<p>El programa puede ser ejecutado en distintos \"controladores\"</p> <ul> <li>Emulador <code>Local</code>.</li> <li>Simulador <code>Um_RT</code> (User Mode Real Time). Recomendado para el laboratorio.</li> <li>Controlador remoto (PLC).</li> </ul>"},{"location":"contenidos/01_conceptos/11_tc3_ejecutar_programa/#emulador-local","title":"Emulador local","text":"<p>Para poder usar este controlador debemos haberle dejado a TwinCAT 3 que tuviera acceso al kernel de Windows durante la instalaci\u00f3n, de manera que pueda hacer uso de, al menos, un core del equipo para ejecutar el programa. </p> <p>El emulador local ejecuta el programa exactamente de la misma manera que si lo hici\u00e9ramos en un equipo remoto pero, obviamente, no tenemos acceso al hardware. De esta forma, podremos interactuar con las variables de entrada y salida mediante la escritura/forzado de variables o usando la visualizaci\u00f3n (si hemos dise\u00f1ado alguna para controlar las variables).</p> <p>En este caso no tendremos que asociar las variables a los terminales de E/S ya que no habr\u00e1 ninguno disponible.</p> <p>Para usar este controlador, simplemente aseg\u00farate de seleccionar <code>Local</code> en el desplegable del <code>Target</code>.</p> <p></p> <p>Importante</p> <p>La instalaci\u00f3n y uso de este modo tiene ciertos requisitos que se cumplen en la mayor\u00eda de los equipos en los que se puede instalar, pero, en ocasiones, puede dar alg\u00fan problema de incompatibilidad. Para estos casos, se recomienda utilizar el simulador local explicado m\u00e1s adelante.</p>"},{"location":"contenidos/01_conceptos/11_tc3_ejecutar_programa/#simulador-local","title":"Simulador local","text":"<p>TwinCAT 3 proporciona una v\u00eda alternativa al emulador local que permite ejecutar c\u00f3digo en un simulador en \"modo usuario\" dentro de Windows. La diferencia principal con el emulador es que \u00e9ste garantiza el tiempo de ciclo del sistema mientras que el simulador no lo hace. A\u00fan as\u00ed, las restricciones de tiempo de los programas que usaremos no son muy exigentes as\u00ed que el simulador ser\u00e1 suficiente para una ejecuci\u00f3n satisfactoria. A cambio, elimina los problemas de compatibilidad que la instalaci\u00f3n del emulador local pueda tener.</p> <p>Al igual que con el emulador local, no tendremos que asociar las variables a los terminales de E/S, ya que no habr\u00e1 ninguno disponible. De nuevo, podremos interactuar con las variables de entrada y salida mediante la escritura/forzado de variables o usando la visualizaci\u00f3n (si hemos dise\u00f1ado alguna para controlar las variables).</p> <p>Para usar este controlador, tendremos que ejecutar en \"modo Administrador\" el archivo <code>TC3_UmRT_Start.bat</code> que proporcionamos en la carpeta <code>Automatizaci\u00f3n &gt; programas</code> del CV. Esto abrir\u00e1 un terminal de Windows con la informaci\u00f3n relativa a la ejecuci\u00f3n del simulador. Minimizaremos esta ventana y la dejaremos trabajar de fondo.</p> <p>Error</p> <p>Se ha detectado que este procedimiento no funciona en los PCs del laboratorio por lo que, alternativamente, hay que realizar lo siguiente:</p> <p>Pulsar <code>Win+R</code> e introducir el siguiente texto:  <code>C:\\TwinCAT\\3.1\\Runtimes\\UmRT_Default\\Start.bat</code></p> <p>Importante</p> <p>No debemos cerrar la ventana del terminal de Windows abierto por <code>TC3_UmRT_Start.bat</code> mientras queramos usar este simulador.</p> <p>Una vez hecho esto, aparecer\u00e1 el texto <code>UmRT_Default</code> en el desplegable del target: </p> <p>Importante</p> <p>Una vez finalizado nuestro trabajo con el simulador, pulsaremos la tecla <code>'x'</code> en el terminal para apagar el simulador y se cerrar\u00e1 autom\u00e1ticamente la ventana.</p>"},{"location":"contenidos/01_conceptos/11_tc3_ejecutar_programa/#controlador-remoto-plc","title":"Controlador remoto (PLC)","text":"<p>Por \u00faltimo, podremos ejecutar nuestro programa en un controlador remoto (por ejemplo, el PLC de alguna de las estaciones). De esta manera, tendremos acceso al hardware que est\u00e9 conectado al controlador y podremos interactuar con \u00e9l.</p> <p>Importante</p> <p>En este punto, asumiremos que ya hemos encontrado el controlador en la red del laboratorio (como se explica aqu\u00ed y ya hemos escaneado los terminales de E/S que est\u00e1n conectados al controlador (como se explica aqu\u00ed).</p> <p>Para usar este controlador, lo seleccionaremos en el desplegable de <code>Target</code>.  </p> <p>Al usar este controlador, tendremos acceso al hardware conectado a \u00e9l, y podremos vincular las variables que hemos declarado en las im\u00e1genes de entrada y salida con los terminales y canales que queramos. Para ello, simplemente repetiremos este proceso para cada variable:</p> <ul> <li> <p>DCI sobre la variable a vincular en la lista que aparece en la secci\u00f3n de instancia del proyecto.</p> <p></p> </li> <li> <p>Seleccionar el terminal/canal deseado del listado que aparece.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/11_tc3_ejecutar_programa/#activar-la-configuracion","title":"Activar la configuraci\u00f3n","text":"<p>Una vez realizada la selecci\u00f3n del controlador y la asociaci\u00f3n de variables con los terminales de E/S (si procede), ahora debemos env\u00edar esta informaci\u00f3n al controlador en cuesti\u00f3n. Esto se denomina Activar la configuraci\u00f3n.</p> <p>Para ello, deberemos pulsar el icono de Activate Configuration y activar el modo de ejecuci\u00f3n (Run Mode) cuando nos lo pregunte TwinCAT3 en una ventana popup.</p> <p></p>"},{"location":"contenidos/01_conceptos/11_tc3_ejecutar_programa/#transferir-y-ejecutar-el-programa","title":"Transferir y ejecutar el programa","text":"<p>Posteriormente, debemos enviar el programa al controlador pulsando el icono de Login, tras lo que se preguntar\u00e1, en un popup, si queremos crear un puerto de comunicaci\u00f3n con el controlador y descargar el programa. Pulsaremos en Yes.</p> <p></p> <p>Finalmente, pondremos el programa en ejecuci\u00f3n pulsando el icono Start.</p> <p></p> <p>Importante</p> <p>Para poder modificar de nuevo el programa, primero hay que parar el programa (Stop) (recomendado) y posteriormente hacer Logout.</p> <p></p>"},{"location":"contenidos/01_conceptos/12_tc3_activar_hw/","title":"12 tc3 activar hw","text":""},{"location":"contenidos/01_conceptos/12_tc3_activar_hw/#activardesactivar-hardware","title":"\ud83d\udd0c Activar/desactivar hardware","text":"<ol> <li>Si has vinculado las variables de tu programa con el equipo remoto (hiciste la b\u00fasqueda del equipo remoto y la exploraci\u00f3n de los m\u00f3dulos de E/S), cuando quieras probar tu programa en el Runtime Local, aparecer\u00e1 una ventana popup indicando un error.</li> <li>Esto se debe a que TC3 quiere establecer conexi\u00f3n con el hardware al que estuviste conectado pero no puede, ya que el <code>Target</code> es el local.</li> <li>Para evitar esto, solo tienes que deshabilitar el hardware haciendo CD sobre el dispositivo buscado y seleccionar Disable.</li> </ol> <p>Importante</p> <p>Recuerda volver a habilitarlo cuando quieras volver a usar el equipo remoto.</p>"},{"location":"contenidos/01_conceptos/13_tc3_busqueda_equipos/","title":"13 tc3 busqueda equipos","text":""},{"location":"contenidos/01_conceptos/13_tc3_busqueda_equipos/#busqueda-de-controladores-remotos","title":"\ud83c\udf10 B\u00fasqueda de controladores remotos","text":"<p>Recomendaci\u00f3n</p> <p>Hay un video de ejemplo en el Campus Virtual en <code>Automatizaci\u00f3n &gt; Videos &gt; TC3</code> con nombre <code>9_Runtime_Target_*.mkv</code>.</p> <p>En esta secci\u00f3n explicaremos c\u00f3mo buscar controladores remotos en la red del laboratorio y c\u00f3mo escanear los terminales/canales que tienen conectados.</p>"},{"location":"contenidos/01_conceptos/13_tc3_busqueda_equipos/#busqueda-en-red","title":"B\u00fasqueda en red","text":"<p>Si queremos utilizar un controlador remoto (PLC), lo primero que debemos hacer es buscarlo en la red local del laboratorio y establecer una conexi\u00f3n con \u00e9l. Para ello, seguiremos este procedimiento:</p> <ul> <li> <p>Desplegar <code>Target</code> y seleccionar <code>Choose Target System...</code>.</p> <p></p> <p></p> <ul> <li> <p>Pulsar sobre <code>Search (Ethernet)</code></p> <p>Importante</p> <p>Aceptar si aparece el siguiente mensaje: Searching for remote system only possible from local system. Change back to local system.</p> <ul> <li> <p>Se abre el siguiente cuadro de di\u00e1logo:</p> <p></p> </li> <li> <p>Seleccionar <code>\ud83d\udd33 Advanced Settings</code>.</p> </li> <li> <p>Pulsar sobre el bot\u00f3n <code>Broadcast Search</code>.</p> <ul> <li> <p>Seleccionar los adaptadores de red en el popup.</p> <p></p> </li> </ul> </li> <li> <p>Seleccionar el PLC de la lista que aparezca.</p> </li> <li>Marcar <code>\ud83d\udd33 IP Address</code></li> <li>Pulsar en el bot\u00f3n <code>Add Route</code>.</li> <li>En el popup que aparece (Add Remote Route):<ul> <li>Deseleccionar <code>\ud83d\udd32 Secure ADS</code></li> <li>Escribir: <code>User</code> el que corresponda (Administrator, por defecto).</li> <li>Escribir: <code>Password</code> la que corresponda (1, por defecto).</li> </ul> </li> <li>Observar que aparece una <code>x</code> en la columna Connected.</li> <li>Cerrar el cuadro de di\u00e1logo pulsando <code>Close</code>.</li> </ul> </li> <li> <p>Ahora deber\u00eda aparecer el controlador en el listado del cuadro de di\u00e1logo <code>Choose Target System</code>:</p> <ul> <li>Seleccionar el controlador en la lista y pulsar <code>OK</code>.</li> </ul> </li> <li>Si aparece un popup indicando que es necesario cambiar la plataforma, pulsar en <code>Yes</code>.</li> </ul> </li> </ul>"},{"location":"contenidos/01_conceptos/13_tc3_busqueda_equipos/#escaneado-del-controlador","title":"Escaneado del controlador","text":"<p>Importante</p> <p>Para poder hacer este proceso, debemos asegurarnos que TwinCAT 3 est\u00e1 en modo configuraci\u00f3n (Configuration Mode) y no en ejecuci\u00f3n (Run Mode).</p> <p></p> <p>Comenzamos por buscar los dispositivos de entrada/salida conectados al controlador. Para ello:</p> <ul> <li> <p>En el explorador de la soluci\u00f3n (<code>Solution Explorer</code>):</p> <ul> <li>Seleccionar: <code>I/O &gt; Device</code>.</li> <li>Pulsar en el men\u00fa <code>TwinCAT &gt; Scan (BD Scan)</code> (alternativamente, CD sobre <code>I/O Device</code> y pulsar <code>Scan</code>).</li> <li>Aceptar el mensaje de que no todos los dispositvos pueden encontrarse autom\u00e1ticamente.</li> <li>Seleccionar \u00fanicamente el dispositivo EtherCAT y pulsar <code>OK</code>.</li> <li>Aceptar la b\u00fasqueda de boxes (terminales) pulsando <code>Yes</code>.</li> <li>Aceptar la activaci\u00f3n del modo Free Run pulsando <code>Yes</code>.</li> </ul> </li> <li> <p>Observar el arbol de I/O en el explorador de la soluci\u00f3n.</p> </li> <li> <p>Desplegar el elemento <code>EK1200</code> y verificar que la lista de terminales se corresponde con la configuraci\u00f3n del controlador (en su documentaci\u00f3n).</p> <p>Info</p> <p>Tened en cuenta que el terminal <code>EL9011</code> es un elemento virtual.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/13_tc3_busqueda_equipos/#comprobacion-de-los-terminales","title":"Comprobaci\u00f3n de los terminales","text":"<p>Ahora vamos a comprobar alguno de los terminales de E/S para asegurarnos de que tenemos acceso a ellos. Usaremos un ejemplo en el que tendremos un programa con una variable de entrada <code>i_PulsadorMarcha</code> y una variable de salida <code>o_LamparaMarcha</code>.</p> <p>El procedimiento a seguir es el siguiente:</p> <ul> <li> <p>Buscar en el listado de E/S del controlador la entrada correspondiente al pulsador de marcha:</p> <ul> <li>Localizar el Terminal y el Canal de entrada especificado.</li> <li>Desplegar el contenido del Canal y hacer DC sobre su <code>Input</code>.</li> <li>Seleccionar la pesta\u00f1a Online y verificar que se corresponde con el pulsador:<ul> <li>Accionar el pulsador de marcha y observar el cambio de valor mostrado en la gr\u00e1fica.</li> </ul> </li> </ul> <p>Importante</p> <p>Se recomienda seleccionar la pesta\u00f1a Variable y cambiar el nombre de <code>Input</code> por el nombre de la variable asociada en el listado de E/S (por ejemplo, <code>i_PulsadorMarcha</code>). </p> <p>Este paso NO vincula el terminal/canal con la variable sino que simplemente lo renombra para ayudarnos a localizarlo posteriormente durante el proceso de vinculaci\u00f3n.</p> </li> <li> <p>Buscar en el listado de E/S del controlador la salida correspondiente a la l\u00e1mpara de marcha:    </p> <ul> <li>Localizar el Terminal y el Canal de salida especificado.</li> <li>Desplegar el contenido del Canal y hacer DC sobre su <code>Output</code>.</li> <li>Seleccionar la pesta\u00f1a Online y verificar que se corresponde con la l\u00e1mpara:<ul> <li>Pulsar <code>Write</code>.</li> <li>Pulsar alternativamente <code>0</code>/<code>1</code> y comprobar que la l\u00e1mpara se enciende y se apaga.</li> </ul> </li> </ul> <p>Importante</p> <p>Se recomienda seleccionar la pesta\u00f1a Variable y cambiar el nombre <code>Output</code> por el nombre de la variable asociada en el listado de E/S (por ejemplo, <code>o_LamparaMarcha</code>). </p> <p>Este paso NO vincula el terminal/canal con la variable sino que simplemente lo renombra para ayudarnos a localizarlo posteriormente durante el proceso de vinculaci\u00f3n.</p> </li> </ul> <p>Una vez realizado esto, guardamos el proyecto.</p>"},{"location":"contenidos/01_conceptos/14_tc3_enlace_es/","title":"14 tc3 enlace es","text":""},{"location":"contenidos/01_conceptos/14_tc3_enlace_es/#vinculacion-de-variables-y-es","title":"\ud83d\udd17 Vinculaci\u00f3n de variables y E/S","text":"<p>Recomendaci\u00f3n</p> <p>Hay un video de ejemplo en el Campus Virtual en <code>Automatizaci\u00f3n &gt; Videos &gt; TC3</code> con nombre <code>9_Runtime_Target_*.mkv</code>.</p> <p>Una vez se han revisados y renombrados los terminales/canales de E/S del controlador, procedemos a vincularlos con las variables de nuestro programa.</p> <p>El procedimiento es el siguiente (siguiendo con el ejemplo anterior de pulsador/l\u00e1mpara):</p> <ul> <li>DC sobre el canal nombrado como <code>o_LamparaMarcha</code> (<code>DB &gt; Change Link...</code>):<ul> <li>Seleccionar la variable que queremos vincular <code>MAIN.o_Lampara</code> en la instancia <code>PLCTask Input</code> y pulsar <code>OK</code>.<ul> <li>Observar c\u00f3mo cambian los iconos del canal <code>o_LamparaMarcha</code> y de la variable <code>MAIN.o_Lampara</code> en la instancia (aparece una flecha sobre el icono en ambos casos, indicando que hay una vinculaci\u00f3n).</li> </ul> </li> </ul> </li> <li> <p>DC sobre la variable <code>MAIN.i_Pulsador</code> en la instancia <code>PLCTask Input</code> (<code>DB &gt; Change Link...</code>)</p> <ul> <li>Seleccionar en I/O el canal correspondiente a i_Pulsador<ul> <li>De la misma manera, cambian los iconos del canal <code>o_LamparaMarcha</code> y de la variable <code>MAIN.o_Lampara</code> en la instancia.</li> </ul> </li> </ul> <p>Info</p> <p>Esta operaci\u00f3n se puede hacer desde la instancia hacia la entrada/salida o al rev\u00e9s.</p> </li> </ul>"},{"location":"contenidos/01_conceptos/15_tc3_interfaz/","title":"15 tc3 interfaz","text":""},{"location":"contenidos/01_conceptos/15_tc3_interfaz/#interfaz-de-twincat-3","title":"Interfaz de TwinCAT 3","text":"<p>La imagen muestra el entorno de desarrollo TwinCAT 3 (TcXaeShell) integrado en Visual Studio. A continuaci\u00f3n se describen las principales zonas de la interfaz:</p> <p></p>"},{"location":"contenidos/01_conceptos/15_tc3_interfaz/#resumen-estructural","title":"Resumen estructural","text":"<p>La interfaz de TC3 se divide conceptualmente en:</p> Zona Funci\u00f3n Barra superior Control del proyecto y del runtime Solution Explorer Organizaci\u00f3n estructural del proyecto Editor central Declaraci\u00f3n de variables (superior) y c\u00f3digo (inferior) Panel de propiedades Configuraci\u00f3n detallada Ventana inferior Diagn\u00f3stico y mensajes"},{"location":"contenidos/01_conceptos/15_tc3_interfaz/#1-menus-y-barra-de-herramientas","title":"1. Men\u00fas y barra de herramientas","text":"<p>En la zona superior encontramos:</p>"},{"location":"contenidos/01_conceptos/15_tc3_interfaz/#barra-de-menus","title":"Barra de men\u00fas","text":"<p>Incluye los men\u00fas cl\u00e1sicos:</p> <ul> <li>File</li> <li>Edit</li> <li>View</li> <li>Project</li> <li>Build</li> <li>Debug</li> <li>TwinCAT</li> <li>etc.</li> </ul> <p>Desde aqu\u00ed se gestionan acciones globales como compilar, activar configuraci\u00f3n, depurar o configurar el runtime.</p>"},{"location":"contenidos/01_conceptos/15_tc3_interfaz/#barra-de-herramientas","title":"Barra de herramientas","text":"<p>Debajo del men\u00fa aparecen accesos r\u00e1pidos a:</p> <ul> <li>Selecci\u00f3n de configuraci\u00f3n (Debug / Release)</li> <li>Selecci\u00f3n del controlador (por ejemplo ) <li>Botones de Activar configuraci\u00f3n, Run Mode, Config Mode, Login, Start, Stop</li> <li>Selecci\u00f3n del proyecto activo</li> <li>Acceso r\u00e1pido a escritura y forzado de variables, reset del controlador, etc.</li>"},{"location":"contenidos/01_conceptos/15_tc3_interfaz/#2-solution-explorer","title":"2. Solution Explorer","text":"<p>Es el \u00e1rbol estructural del proyecto.</p> <p>Aqu\u00ed se organizan:</p> <ul> <li>Solution<ul> <li>Proyecto PLC</li> <li>POUs (Program Organization Units)</li> <li>DUTs (Tipos de datos)</li> <li>GVLs (Variables globales)</li> <li>Visualizaciones</li> <li>Referencias</li> <li>I/O</li> <li>Tasks</li> </ul> </li> </ul> <p>Permite:</p> <ul> <li>Crear nuevos bloques (FB, PRG, etc.)</li> <li>A\u00f1adir tipos de datos</li> <li>Configurar hardware</li> <li>Gestionar instancias</li> </ul> <p>Es el centro de navegaci\u00f3n del proyecto.</p>"},{"location":"contenidos/01_conceptos/15_tc3_interfaz/#3-editor-central","title":"3. Editor central","text":"<p>Zona central del trabajo. Es el \u00e1rea donde se edita el c\u00f3digo y los diagramas.</p> <p>Puede mostrar distintos tipos de editores:</p> <ul> <li>Structured Text (ST)</li> <li>Ladder (LD)</li> <li>FBD</li> <li>SFC</li> <li>Visualizaciones</li> </ul> <p>En la imagen se observan dos zonas diferenciadas dentro del mismo bloque:</p>"},{"location":"contenidos/01_conceptos/15_tc3_interfaz/#declaracion-de-variables-parte-superior","title":"Declaraci\u00f3n de variables (parte superior)","text":"<p>Aqu\u00ed se definen:</p> <ul> <li><code>VAR_INPUT</code></li> <li><code>VAR_OUTPUT</code></li> <li><code>VAR</code></li> <li>Enumeraciones</li> <li>Instancias de bloques</li> <li>Variables mapeadas a entradas/salidas f\u00edsicas</li> </ul> <p>Es la zona donde se define la interfaz y memoria del bloque.</p>"},{"location":"contenidos/01_conceptos/15_tc3_interfaz/#zona-de-codigo-parte-inferior","title":"Zona de c\u00f3digo (parte inferior)","text":"<p>Aqu\u00ed se implementa el c\u00f3digo del bloque. En el ejemplo se visualiza un diagrama SFC con:</p> <ul> <li>Pasos (<code>S0</code>, <code>S1</code>, <code>S2</code>...)</li> <li>Transiciones</li> <li>Acciones asociadas</li> <li>Condiciones l\u00f3gicas</li> </ul> <p>Pero se puede programar en cualquier lenguaje de la norma IEC-61131-3.</p>"},{"location":"contenidos/01_conceptos/15_tc3_interfaz/#4-ventana-de-propiedades","title":"4. Ventana de Propiedades","text":"<p>Muestra las propiedades del elemento seleccionado:</p> <ul> <li>Nombre</li> <li>Comentario</li> <li>Paso inicial</li> <li>Acciones asociadas</li> <li>Tiempos m\u00ednimos o m\u00e1ximos</li> <li>Configuraci\u00f3n espec\u00edfica del objeto</li> </ul> <p>Es contextual: cambia seg\u00fan lo que est\u00e9 seleccionado (paso SFC, variable, bloque, etc.).</p>"},{"location":"contenidos/01_conceptos/15_tc3_interfaz/#5-zona-inferior-output-error-list","title":"5. Zona inferior (Output / Error List)","text":"<p>En la parte inferior aparecen pesta\u00f1as como:</p> <ul> <li>Error List</li> <li>Output</li> <li>Estado de compilaci\u00f3n</li> </ul> <p>Sirve para:</p> <ul> <li>Ver errores de compilaci\u00f3n</li> <li>Advertencias</li> <li>Mensajes del sistema</li> <li>Informaci\u00f3n de activaci\u00f3n</li> </ul>"}]}